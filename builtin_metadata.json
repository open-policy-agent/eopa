{
  "_categories": {
    "aggregates": [
      "count",
      "max",
      "min",
      "product",
      "sort",
      "sum"
    ],
    "array": [
      "array.concat",
      "array.reverse",
      "array.slice"
    ],
    "bits": [
      "bits.and",
      "bits.lsh",
      "bits.negate",
      "bits.or",
      "bits.rsh",
      "bits.xor"
    ],
    "comparison": [
      "equal",
      "gt",
      "gte",
      "lt",
      "lte",
      "neq"
    ],
    "conversions": [
      "to_number"
    ],
    "crypto": [
      "crypto.hmac.equal",
      "crypto.hmac.md5",
      "crypto.hmac.sha1",
      "crypto.hmac.sha256",
      "crypto.hmac.sha512",
      "crypto.md5",
      "crypto.parse_private_keys",
      "crypto.sha1",
      "crypto.sha256",
      "crypto.x509.parse_and_verify_certificates",
      "crypto.x509.parse_and_verify_certificates_with_options",
      "crypto.x509.parse_certificate_request",
      "crypto.x509.parse_certificates",
      "crypto.x509.parse_keypair",
      "crypto.x509.parse_rsa_private_key"
    ],
    "dynamodb": [
      "dynamodb.get",
      "dynamodb.query"
    ],
    "encoding": [
      "base64.decode",
      "base64.encode",
      "base64.is_valid",
      "base64url.decode",
      "base64url.encode",
      "base64url.encode_no_pad",
      "hex.decode",
      "hex.encode",
      "json.is_valid",
      "json.marshal",
      "json.marshal_with_options",
      "json.unmarshal",
      "urlquery.decode",
      "urlquery.decode_object",
      "urlquery.encode",
      "urlquery.encode_object",
      "yaml.is_valid",
      "yaml.marshal",
      "yaml.unmarshal"
    ],
    "glob": [
      "glob.match",
      "glob.quote_meta"
    ],
    "graph": [
      "graph.reachable",
      "graph.reachable_paths",
      "walk"
    ],
    "graphql": [
      "graphql.is_valid",
      "graphql.parse",
      "graphql.parse_and_verify",
      "graphql.parse_query",
      "graphql.parse_schema",
      "graphql.schema_is_valid"
    ],
    "http": [
      "http.send"
    ],
    "internal": [
      "internal.member_2",
      "internal.member_3",
      "internal.print",
      "internal.test_case"
    ],
    "mongodb": [
      "mongodb.find",
      "mongodb.find_one"
    ],
    "neo4j": [
      "neo4j.query"
    ],
    "net": [
      "net.cidr_contains",
      "net.cidr_contains_matches",
      "net.cidr_expand",
      "net.cidr_intersects",
      "net.cidr_is_valid",
      "net.cidr_merge",
      "net.lookup_ip_addr"
    ],
    "numbers": [
      "abs",
      "ceil",
      "div",
      "floor",
      "minus",
      "mul",
      "numbers.range",
      "numbers.range_step",
      "plus",
      "rand.intn",
      "rem",
      "round"
    ],
    "object": [
      "json.filter",
      "json.match_schema",
      "json.patch",
      "json.remove",
      "json.verify_schema",
      "object.filter",
      "object.get",
      "object.keys",
      "object.remove",
      "object.subset",
      "object.union",
      "object.union_n"
    ],
    "opa": [
      "opa.runtime"
    ],
    "providers.aws": [
      "providers.aws.sign_req"
    ],
    "redis": [
      "redis.query"
    ],
    "regex": [
      "regex.find_all_string_submatch_n",
      "regex.find_n",
      "regex.globs_match",
      "regex.is_valid",
      "regex.match",
      "regex.replace",
      "regex.split",
      "regex.template_match"
    ],
    "rego": [
      "rego.compile",
      "rego.eval",
      "rego.metadata.chain",
      "rego.metadata.rule",
      "rego.parse_module"
    ],
    "semver": [
      "semver.compare",
      "semver.is_valid"
    ],
    "sets": [
      "and",
      "intersection",
      "minus",
      "or",
      "union"
    ],
    "sql": [
      "sql.send"
    ],
    "strings": [
      "concat",
      "contains",
      "endswith",
      "format_int",
      "indexof",
      "indexof_n",
      "lower",
      "replace",
      "split",
      "sprintf",
      "startswith",
      "strings.any_prefix_match",
      "strings.any_suffix_match",
      "strings.count",
      "strings.render_template",
      "strings.replace_n",
      "strings.reverse",
      "substring",
      "trim",
      "trim_left",
      "trim_prefix",
      "trim_right",
      "trim_space",
      "trim_suffix",
      "upper"
    ],
    "time": [
      "time.add_date",
      "time.clock",
      "time.date",
      "time.diff",
      "time.format",
      "time.now_ns",
      "time.parse_duration_ns",
      "time.parse_ns",
      "time.parse_rfc3339_ns",
      "time.weekday"
    ],
    "tokens": [
      "io.jwt.decode",
      "io.jwt.decode_verify",
      "io.jwt.verify_es256",
      "io.jwt.verify_es384",
      "io.jwt.verify_es512",
      "io.jwt.verify_hs256",
      "io.jwt.verify_hs384",
      "io.jwt.verify_hs512",
      "io.jwt.verify_ps256",
      "io.jwt.verify_ps384",
      "io.jwt.verify_ps512",
      "io.jwt.verify_rs256",
      "io.jwt.verify_rs384",
      "io.jwt.verify_rs512"
    ],
    "tokensign": [
      "io.jwt.encode_sign",
      "io.jwt.encode_sign_raw"
    ],
    "tracing": [
      "trace"
    ],
    "types": [
      "is_array",
      "is_boolean",
      "is_null",
      "is_number",
      "is_object",
      "is_set",
      "is_string",
      "type_name"
    ],
    "units": [
      "units.parse",
      "units.parse_bytes"
    ],
    "uuid": [
      "uuid.parse",
      "uuid.rfc4122"
    ],
    "vault": [
      "vault.send"
    ]
  },
  "abs": {
    "args": [
      {
        "description": "the number to take the absolute value of",
        "name": "x",
        "type": "number"
      }
    ],
    "description": "Returns the number without its sign.",
    "result": {
      "description": "the absolute value of `x`",
      "name": "y",
      "type": "number"
    }
  },
  "all": {
    "args": [
      {
        "type": "any\u003carray[any], set[any]\u003e"
      }
    ],
    "deprecated": true,
    "result": {
      "type": "boolean"
    }
  },
  "and": {
    "args": [
      {
        "description": "the first set",
        "name": "x",
        "type": "set[any]"
      },
      {
        "description": "the second set",
        "name": "y",
        "type": "set[any]"
      }
    ],
    "description": "Returns the intersection of two sets.",
    "infix": "\u0026",
    "result": {
      "description": "the intersection of `x` and `y`",
      "name": "z",
      "type": "set[any]"
    }
  },
  "any": {
    "args": [
      {
        "type": "any\u003carray[any], set[any]\u003e"
      }
    ],
    "deprecated": true,
    "result": {
      "type": "boolean"
    }
  },
  "array.concat": {
    "args": [
      {
        "description": "the first array",
        "name": "x",
        "type": "array[any]"
      },
      {
        "description": "the second array",
        "name": "y",
        "type": "array[any]"
      }
    ],
    "description": "Concatenates two arrays.",
    "result": {
      "description": "the concatenation of `x` and `y`",
      "name": "z",
      "type": "array[any]"
    }
  },
  "array.reverse": {
    "args": [
      {
        "description": "the array to be reversed",
        "name": "arr",
        "type": "array[any]"
      }
    ],
    "description": "Returns the reverse of a given array.",
    "result": {
      "description": "an array containing the elements of `arr` in reverse order",
      "name": "rev",
      "type": "array[any]"
    }
  },
  "array.slice": {
    "args": [
      {
        "description": "the array to be sliced",
        "name": "arr",
        "type": "array[any]"
      },
      {
        "description": "the start index of the returned slice; if less than zero, it's clamped to 0",
        "name": "start",
        "type": "number"
      },
      {
        "description": "the stop index of the returned slice; if larger than `count(arr)`, it's clamped to `count(arr)`",
        "name": "stop",
        "type": "number"
      }
    ],
    "description": "Returns a slice of a given array. If `start` is greater or equal than `stop`, `slice` is `[]`.",
    "result": {
      "description": "the subslice of `array`, from `start` to `end`, including `arr[start]`, but excluding `arr[end]`",
      "name": "slice",
      "type": "array[any]"
    }
  },
  "assign": {
    "args": [
      {
        "type": "any"
      },
      {
        "type": "any"
      }
    ],
    "infix": ":=",
    "result": {
      "type": "boolean"
    }
  },
  "base64.decode": {
    "args": [
      {
        "description": "string to decode",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Deserializes the base64 encoded input string.",
    "result": {
      "description": "base64 deserialization of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "base64.encode": {
    "args": [
      {
        "description": "string to encode",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Serializes the input string into base64 encoding.",
    "result": {
      "description": "base64 serialization of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "base64.is_valid": {
    "args": [
      {
        "description": "string to check",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Verifies the input string is base64 encoded.",
    "result": {
      "description": "`true` if `x` is valid base64 encoded value, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "base64url.decode": {
    "args": [
      {
        "description": "string to decode",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Deserializes the base64url encoded input string.",
    "result": {
      "description": "base64url deserialization of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "base64url.encode": {
    "args": [
      {
        "description": "string to encode",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Serializes the input string into base64url encoding.",
    "result": {
      "description": "base64url serialization of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "base64url.encode_no_pad": {
    "args": [
      {
        "description": "string to encode",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Serializes the input string into base64url encoding without padding.",
    "result": {
      "description": "base64url serialization of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "bits.and": {
    "args": [
      {
        "description": "the first integer",
        "name": "x",
        "type": "number"
      },
      {
        "description": "the second integer",
        "name": "y",
        "type": "number"
      }
    ],
    "description": "Returns the bitwise \"AND\" of two integers.",
    "result": {
      "description": "the bitwise AND of `x` and `y`",
      "name": "z",
      "type": "number"
    }
  },
  "bits.lsh": {
    "args": [
      {
        "description": "the integer to shift",
        "name": "x",
        "type": "number"
      },
      {
        "description": "the number of bits to shift",
        "name": "s",
        "type": "number"
      }
    ],
    "description": "Returns a new integer with its bits shifted `s` bits to the left.",
    "result": {
      "description": "the result of shifting `x` `s` bits to the left",
      "name": "z",
      "type": "number"
    }
  },
  "bits.negate": {
    "args": [
      {
        "description": "the integer to negate",
        "name": "x",
        "type": "number"
      }
    ],
    "description": "Returns the bitwise negation (flip) of an integer.",
    "result": {
      "description": "the bitwise negation of `x`",
      "name": "z",
      "type": "number"
    }
  },
  "bits.or": {
    "args": [
      {
        "description": "the first integer",
        "name": "x",
        "type": "number"
      },
      {
        "description": "the second integer",
        "name": "y",
        "type": "number"
      }
    ],
    "description": "Returns the bitwise \"OR\" of two integers.",
    "result": {
      "description": "the bitwise OR of `x` and `y`",
      "name": "z",
      "type": "number"
    }
  },
  "bits.rsh": {
    "args": [
      {
        "description": "the integer to shift",
        "name": "x",
        "type": "number"
      },
      {
        "description": "the number of bits to shift",
        "name": "s",
        "type": "number"
      }
    ],
    "description": "Returns a new integer with its bits shifted `s` bits to the right.",
    "result": {
      "description": "the result of shifting `x` `s` bits to the right",
      "name": "z",
      "type": "number"
    }
  },
  "bits.xor": {
    "args": [
      {
        "description": "the first integer",
        "name": "x",
        "type": "number"
      },
      {
        "description": "the second integer",
        "name": "y",
        "type": "number"
      }
    ],
    "description": "Returns the bitwise \"XOR\" (exclusive-or) of two integers.",
    "result": {
      "description": "the bitwise XOR of `x` and `y`",
      "name": "z",
      "type": "number"
    }
  },
  "cast_array": {
    "args": [
      {
        "type": "any"
      }
    ],
    "deprecated": true,
    "result": {
      "type": "array[any]"
    }
  },
  "cast_boolean": {
    "args": [
      {
        "type": "any"
      }
    ],
    "deprecated": true,
    "result": {
      "type": "boolean"
    }
  },
  "cast_null": {
    "args": [
      {
        "type": "any"
      }
    ],
    "deprecated": true,
    "result": {
      "type": "null"
    }
  },
  "cast_object": {
    "args": [
      {
        "type": "any"
      }
    ],
    "deprecated": true,
    "result": {
      "type": "object[any: any]"
    }
  },
  "cast_set": {
    "args": [
      {
        "type": "any"
      }
    ],
    "deprecated": true,
    "result": {
      "type": "set[any]"
    }
  },
  "cast_string": {
    "args": [
      {
        "type": "any"
      }
    ],
    "deprecated": true,
    "result": {
      "type": "string"
    }
  },
  "ceil": {
    "args": [
      {
        "description": "the number to round",
        "name": "x",
        "type": "number"
      }
    ],
    "description": "Rounds the number _up_ to the nearest integer.",
    "result": {
      "description": "the result of rounding `x` _up_",
      "name": "y",
      "type": "number"
    }
  },
  "concat": {
    "args": [
      {
        "description": "string to use as a delimiter",
        "name": "delimiter",
        "type": "string"
      },
      {
        "description": "strings to join",
        "name": "collection",
        "type": "any\u003carray[string], set[string]\u003e"
      }
    ],
    "description": "Joins a set or array of strings with a delimiter.",
    "result": {
      "description": "the joined string",
      "name": "output",
      "type": "string"
    }
  },
  "contains": {
    "args": [
      {
        "description": "string to search in",
        "name": "haystack",
        "type": "string"
      },
      {
        "description": "substring to look for",
        "name": "needle",
        "type": "string"
      }
    ],
    "description": "Returns `true` if the search string is included in the base string",
    "result": {
      "description": "result of the containment check",
      "name": "result",
      "type": "boolean"
    }
  },
  "count": {
    "args": [
      {
        "description": "the set/array/object/string to be counted",
        "name": "collection",
        "type": "any\u003cstring, array[any], object[any: any], set[any]\u003e"
      }
    ],
    "description": " Count takes a collection or string and returns the number of elements (or characters) in it.",
    "result": {
      "description": "the count of elements, key/val pairs, or characters, respectively.",
      "name": "n",
      "type": "number"
    }
  },
  "crypto.hmac.equal": {
    "args": [
      {
        "description": "mac1 to compare",
        "name": "mac1",
        "type": "string"
      },
      {
        "description": "mac2 to compare",
        "name": "mac2",
        "type": "string"
      }
    ],
    "description": "Returns a boolean representing the result of comparing two MACs for equality without leaking timing information.",
    "result": {
      "description": "`true` if the MACs are equals, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "crypto.hmac.md5": {
    "args": [
      {
        "description": "input string",
        "name": "x",
        "type": "string"
      },
      {
        "description": "key to use",
        "name": "key",
        "type": "string"
      }
    ],
    "description": "Returns a string representing the MD5 HMAC of the input message using the input key.",
    "result": {
      "description": "MD5-HMAC of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "crypto.hmac.sha1": {
    "args": [
      {
        "description": "input string",
        "name": "x",
        "type": "string"
      },
      {
        "description": "key to use",
        "name": "key",
        "type": "string"
      }
    ],
    "description": "Returns a string representing the SHA1 HMAC of the input message using the input key.",
    "result": {
      "description": "SHA1-HMAC of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "crypto.hmac.sha256": {
    "args": [
      {
        "description": "input string",
        "name": "x",
        "type": "string"
      },
      {
        "description": "key to use",
        "name": "key",
        "type": "string"
      }
    ],
    "description": "Returns a string representing the SHA256 HMAC of the input message using the input key.",
    "result": {
      "description": "SHA256-HMAC of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "crypto.hmac.sha512": {
    "args": [
      {
        "description": "input string",
        "name": "x",
        "type": "string"
      },
      {
        "description": "key to use",
        "name": "key",
        "type": "string"
      }
    ],
    "description": "Returns a string representing the SHA512 HMAC of the input message using the input key.",
    "result": {
      "description": "SHA512-HMAC of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "crypto.md5": {
    "args": [
      {
        "description": "input string",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Returns a string representing the input string hashed with the MD5 function",
    "result": {
      "description": "MD5-hash of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "crypto.parse_private_keys": {
    "args": [
      {
        "description": "PEM encoded data containing one or more private keys as concatenated blocks. Optionally Base64 encoded.",
        "name": "keys",
        "type": "string"
      }
    ],
    "description": "Returns zero or more private keys from the given encoded string containing DER certificate data.\n\nIf the input is empty, the function will return null. The input string should be a list of one or more concatenated PEM blocks. The whole input of concatenated PEM blocks can optionally be Base64 encoded.",
    "result": {
      "description": "parsed private keys represented as objects",
      "name": "output",
      "type": "array[object[string: any]]"
    }
  },
  "crypto.sha1": {
    "args": [
      {
        "description": "input string",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Returns a string representing the input string hashed with the SHA1 function",
    "result": {
      "description": "SHA1-hash of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "crypto.sha256": {
    "args": [
      {
        "description": "input string",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Returns a string representing the input string hashed with the SHA256 function",
    "result": {
      "description": "SHA256-hash of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "crypto.x509.parse_and_verify_certificates": {
    "args": [
      {
        "description": "base64 encoded DER or PEM data containing two or more certificates where the first is a root CA, the last is a leaf certificate, and all others are intermediate CAs",
        "name": "certs",
        "type": "string"
      }
    ],
    "description": "Returns one or more certificates from the given string containing PEM\nor base64 encoded DER certificates after verifying the supplied certificates form a complete\ncertificate chain back to a trusted root.\n\nThe first certificate is treated as the root and the last is treated as the leaf,\nwith all others being treated as intermediates.",
    "result": {
      "description": "array of `[valid, certs]`: if the input certificate chain could be verified then `valid` is `true` and `certs` is an array of X.509 certificates represented as objects; if the input certificate chain could not be verified then `valid` is `false` and `certs` is `[]`",
      "name": "output",
      "type": "array\u003cboolean, array[object[string: any]]\u003e"
    }
  },
  "crypto.x509.parse_and_verify_certificates_with_options": {
    "args": [
      {
        "description": "base64 encoded DER or PEM data containing two or more certificates where the first is a root CA, the last is a leaf certificate, and all others are intermediate CAs",
        "name": "certs",
        "type": "string"
      },
      {
        "description": "object containing extra configs to verify the validity of certificates. `options` object supports four fields which maps to same fields in [x509.VerifyOptions struct](https://pkg.go.dev/crypto/x509#VerifyOptions). `DNSName`, `CurrentTime`: Nanoseconds since the Unix Epoch as a number, `MaxConstraintComparisons` and `KeyUsages`. `KeyUsages` is list and can have possible values as in: `\"KeyUsageAny\"`, `\"KeyUsageServerAuth\"`, `\"KeyUsageClientAuth\"`, `\"KeyUsageCodeSigning\"`, `\"KeyUsageEmailProtection\"`, `\"KeyUsageIPSECEndSystem\"`, `\"KeyUsageIPSECTunnel\"`, `\"KeyUsageIPSECUser\"`, `\"KeyUsageTimeStamping\"`, `\"KeyUsageOCSPSigning\"`, `\"KeyUsageMicrosoftServerGatedCrypto\"`, `\"KeyUsageNetscapeServerGatedCrypto\"`, `\"KeyUsageMicrosoftCommercialCodeSigning\"`, `\"KeyUsageMicrosoftKernelCodeSigning\"` ",
        "name": "options",
        "type": "object[string: any]"
      }
    ],
    "description": "Returns one or more certificates from the given string containing PEM\nor base64 encoded DER certificates after verifying the supplied certificates form a complete\ncertificate chain back to a trusted root. A config option passed as the second argument can\nbe used to configure the validation options used.\n\nThe first certificate is treated as the root and the last is treated as the leaf,\nwith all others being treated as intermediates.",
    "result": {
      "description": "array of `[valid, certs]`: if the input certificate chain could be verified then `valid` is `true` and `certs` is an array of X.509 certificates represented as objects; if the input certificate chain could not be verified then `valid` is `false` and `certs` is `[]`",
      "name": "output",
      "type": "array\u003cboolean, array[object[string: any]]\u003e"
    }
  },
  "crypto.x509.parse_certificate_request": {
    "args": [
      {
        "description": "base64 string containing either a PEM encoded or DER CSR or a string containing a PEM CSR",
        "name": "csr",
        "type": "string"
      }
    ],
    "description": "Returns a PKCS #10 certificate signing request from the given PEM-encoded PKCS#10 certificate signing request.",
    "result": {
      "description": "X.509 CSR represented as an object",
      "name": "output",
      "type": "object[string: any]"
    }
  },
  "crypto.x509.parse_certificates": {
    "args": [
      {
        "description": "base64 encoded DER or PEM data containing one or more certificates or a PEM string of one or more certificates",
        "name": "certs",
        "type": "string"
      }
    ],
    "description": "Returns zero or more certificates from the given encoded string containing\nDER certificate data.\n\nIf the input is empty, the function will return null. The input string should be a list of one or more\nconcatenated PEM blocks. The whole input of concatenated PEM blocks can optionally be Base64 encoded.",
    "result": {
      "description": "parsed X.509 certificates represented as objects",
      "name": "output",
      "type": "array[object[string: any]]"
    }
  },
  "crypto.x509.parse_keypair": {
    "args": [
      {
        "description": "string containing PEM or base64 encoded DER certificates",
        "name": "cert",
        "type": "string"
      },
      {
        "description": "string containing PEM or base64 encoded DER keys",
        "name": "pem",
        "type": "string"
      }
    ],
    "description": "Returns a valid key pair",
    "result": {
      "description": "if key pair is valid, returns the tls.certificate(https://pkg.go.dev/crypto/tls#Certificate) as an object. If the key pair is invalid, nil and an error are returned.",
      "name": "output",
      "type": "object[string: any]"
    }
  },
  "crypto.x509.parse_rsa_private_key": {
    "args": [
      {
        "description": "base64 string containing a PEM encoded RSA private key",
        "name": "pem",
        "type": "string"
      }
    ],
    "description": "Returns a JWK for signing a JWT from the given PEM-encoded RSA private key.",
    "result": {
      "description": "JWK as an object",
      "name": "output",
      "type": "object[string: any]"
    }
  },
  "div": {
    "args": [
      {
        "description": "the dividend",
        "name": "x",
        "type": "number"
      },
      {
        "description": "the divisor",
        "name": "y",
        "type": "number"
      }
    ],
    "description": "Divides the first number by the second number.",
    "infix": "/",
    "result": {
      "description": "the result of `x` divided by `y`",
      "name": "z",
      "type": "number"
    }
  },
  "dynamodb.get": {
    "args": [
      {
        "description": "query object",
        "name": "request",
        "type": "object[string: any]"
      }
    ],
    "description": "Returns DynamoDB get result row.",
    "result": {
      "description": "result row",
      "name": "response",
      "type": "object[any: any]"
    }
  },
  "dynamodb.query": {
    "args": [
      {
        "description": "query object",
        "name": "request",
        "type": "object[string: any]"
      }
    ],
    "description": "Returns DynamoDB query result rows.",
    "result": {
      "description": "result row",
      "name": "response",
      "type": "object[any: any]"
    }
  },
  "endswith": {
    "args": [
      {
        "description": "search string",
        "name": "search",
        "type": "string"
      },
      {
        "description": "base string",
        "name": "base",
        "type": "string"
      }
    ],
    "description": "Returns true if the search string ends with the base string.",
    "result": {
      "description": "result of the suffix check",
      "name": "result",
      "type": "boolean"
    }
  },
  "eq": {
    "args": [
      {
        "type": "any"
      },
      {
        "type": "any"
      }
    ],
    "infix": "=",
    "result": {
      "type": "boolean"
    }
  },
  "equal": {
    "args": [
      {
        "name": "x",
        "type": "any"
      },
      {
        "name": "y",
        "type": "any"
      }
    ],
    "infix": "==",
    "result": {
      "description": "true if `x` is equal to `y`; false otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "floor": {
    "args": [
      {
        "description": "the number to round",
        "name": "x",
        "type": "number"
      }
    ],
    "description": "Rounds the number _down_ to the nearest integer.",
    "result": {
      "description": "the result of rounding `x` _down_",
      "name": "y",
      "type": "number"
    }
  },
  "format_int": {
    "args": [
      {
        "description": "number to format",
        "name": "number",
        "type": "number"
      },
      {
        "description": "base of number representation to use",
        "name": "base",
        "type": "number"
      }
    ],
    "description": "Returns the string representation of the number in the given base after rounding it down to an integer value.",
    "result": {
      "description": "formatted number",
      "name": "output",
      "type": "string"
    }
  },
  "glob.match": {
    "args": [
      {
        "description": "glob pattern",
        "name": "pattern",
        "type": "string"
      },
      {
        "description": "glob pattern delimiters, e.g. `[\".\", \":\"]`, defaults to `[\".\"]` if unset. If `delimiters` is `null`, glob match without delimiter.",
        "name": "delimiters",
        "type": "any\u003cnull, array[string]\u003e"
      },
      {
        "description": "string to match against `pattern`",
        "name": "match",
        "type": "string"
      }
    ],
    "description": "Parses and matches strings against the glob notation. Not to be confused with `regex.globs_match`.",
    "result": {
      "description": "true if `match` can be found in `pattern` which is separated by `delimiters`",
      "name": "result",
      "type": "boolean"
    }
  },
  "glob.quote_meta": {
    "args": [
      {
        "description": "glob pattern",
        "name": "pattern",
        "type": "string"
      }
    ],
    "description": "Returns a string which represents a version of the pattern where all asterisks have been escaped.",
    "result": {
      "description": "the escaped string of `pattern`",
      "name": "output",
      "type": "string"
    }
  },
  "graph.reachable": {
    "args": [
      {
        "description": "object containing a set or array of neighboring vertices",
        "name": "graph",
        "type": "object[any: any\u003carray[any], set[any]\u003e]"
      },
      {
        "description": "set or array of root vertices",
        "name": "initial",
        "type": "any\u003carray[any], set[any]\u003e"
      }
    ],
    "description": "Computes the set of reachable nodes in the graph from a set of starting nodes.",
    "result": {
      "description": "set of vertices reachable from the `initial` vertices in the directed `graph`",
      "name": "output",
      "type": "set[any]"
    }
  },
  "graph.reachable_paths": {
    "args": [
      {
        "description": "object containing a set or array of root vertices",
        "name": "graph",
        "type": "object[any: any\u003carray[any], set[any]\u003e]"
      },
      {
        "description": "initial paths",
        "name": "initial",
        "type": "any\u003carray[any], set[any]\u003e"
      }
    ],
    "description": "Computes the set of reachable paths in the graph from a set of starting nodes.",
    "result": {
      "description": "paths reachable from the `initial` vertices in the directed `graph`",
      "name": "output",
      "type": "set[array[any]]"
    }
  },
  "graphql.is_valid": {
    "args": [
      {
        "description": "the GraphQL query",
        "name": "query",
        "type": "any\u003cstring, object[any: any]\u003e"
      },
      {
        "description": "the GraphQL schema",
        "name": "schema",
        "type": "any\u003cstring, object[any: any]\u003e"
      }
    ],
    "description": "Checks that a GraphQL query is valid against a given schema. The query and/or schema can be either GraphQL strings or AST objects from the other GraphQL builtin functions.",
    "result": {
      "description": "`true` if the query is valid under the given schema. `false` otherwise.",
      "name": "output",
      "type": "boolean"
    }
  },
  "graphql.parse": {
    "args": [
      {
        "description": "the GraphQL query",
        "name": "query",
        "type": "any\u003cstring, object[any: any]\u003e"
      },
      {
        "description": "the GraphQL schema",
        "name": "schema",
        "type": "any\u003cstring, object[any: any]\u003e"
      }
    ],
    "description": "Returns AST objects for a given GraphQL query and schema after validating the query against the schema. Returns undefined if errors were encountered during parsing or validation. The query and/or schema can be either GraphQL strings or AST objects from the other GraphQL builtin functions.",
    "result": {
      "description": "`output` is of the form `[query_ast, schema_ast]`. If the GraphQL query is valid given the provided schema, then `query_ast` and `schema_ast` are objects describing the ASTs for the query and schema.",
      "name": "output",
      "type": "array\u003cobject[any: any], object[any: any]\u003e"
    }
  },
  "graphql.parse_and_verify": {
    "args": [
      {
        "description": "the GraphQL query",
        "name": "query",
        "type": "any\u003cstring, object[any: any]\u003e"
      },
      {
        "description": "the GraphQL schema",
        "name": "schema",
        "type": "any\u003cstring, object[any: any]\u003e"
      }
    ],
    "description": "Returns a boolean indicating success or failure alongside the parsed ASTs for a given GraphQL query and schema after validating the query against the schema. The query and/or schema can be either GraphQL strings or AST objects from the other GraphQL builtin functions.",
    "result": {
      "description": " `output` is of the form `[valid, query_ast, schema_ast]`. If the query is valid given the provided schema, then `valid` is `true`, and `query_ast` and `schema_ast` are objects describing the ASTs for the GraphQL query and schema. Otherwise, `valid` is `false` and `query_ast` and `schema_ast` are `{}`.",
      "name": "output",
      "type": "array\u003cboolean, object[any: any], object[any: any]\u003e"
    }
  },
  "graphql.parse_query": {
    "args": [
      {
        "description": "GraphQL query string",
        "name": "query",
        "type": "string"
      }
    ],
    "description": "Returns an AST object for a GraphQL query.",
    "result": {
      "description": "AST object for the GraphQL query.",
      "name": "output",
      "type": "object[any: any]"
    }
  },
  "graphql.parse_schema": {
    "args": [
      {
        "description": "GraphQL schema string",
        "name": "schema",
        "type": "string"
      }
    ],
    "description": "Returns an AST object for a GraphQL schema.",
    "result": {
      "description": "AST object for the GraphQL schema.",
      "name": "output",
      "type": "object[any: any]"
    }
  },
  "graphql.schema_is_valid": {
    "args": [
      {
        "description": "the schema to verify",
        "name": "schema",
        "type": "any\u003cstring, object[any: any]\u003e"
      }
    ],
    "description": "Checks that the input is a valid GraphQL schema. The schema can be either a GraphQL string or an AST object from the other GraphQL builtin functions.",
    "result": {
      "description": "`true` if the schema is a valid GraphQL schema. `false` otherwise.",
      "name": "output",
      "type": "boolean"
    }
  },
  "gt": {
    "args": [
      {
        "name": "x",
        "type": "any"
      },
      {
        "name": "y",
        "type": "any"
      }
    ],
    "infix": "\u003e",
    "result": {
      "description": "true if `x` is greater than `y`; false otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "gte": {
    "args": [
      {
        "name": "x",
        "type": "any"
      },
      {
        "name": "y",
        "type": "any"
      }
    ],
    "infix": "\u003e=",
    "result": {
      "description": "true if `x` is greater or equal to `y`; false otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "hex.decode": {
    "args": [
      {
        "description": "a hex-encoded string",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Deserializes the hex-encoded input string.",
    "result": {
      "description": "deserialized from `x`",
      "name": "y",
      "type": "string"
    }
  },
  "hex.encode": {
    "args": [
      {
        "description": "string to encode",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Serializes the input string using hex-encoding.",
    "result": {
      "description": "serialization of `x` using hex-encoding",
      "name": "y",
      "type": "string"
    }
  },
  "http.send": {
    "args": [
      {
        "description": "the HTTP request object",
        "name": "request",
        "type": "object[string: any]"
      }
    ],
    "description": "Returns a HTTP response to the given HTTP request.",
    "result": {
      "description": "the HTTP response object",
      "name": "response",
      "type": "object[any: any]"
    }
  },
  "indexof": {
    "args": [
      {
        "description": "string to search in",
        "name": "haystack",
        "type": "string"
      },
      {
        "description": "substring to look for",
        "name": "needle",
        "type": "string"
      }
    ],
    "description": "Returns the index of a substring contained inside a string.",
    "result": {
      "description": "index of first occurrence, `-1` if not found",
      "name": "output",
      "type": "number"
    }
  },
  "indexof_n": {
    "args": [
      {
        "description": "string to search in",
        "name": "haystack",
        "type": "string"
      },
      {
        "description": "substring to look for",
        "name": "needle",
        "type": "string"
      }
    ],
    "description": "Returns a list of all the indexes of a substring contained inside a string.",
    "result": {
      "description": "all indices at which `needle` occurs in `haystack`, may be empty",
      "name": "output",
      "type": "array[number]"
    }
  },
  "internal.member_2": {
    "args": [
      {
        "type": "any"
      },
      {
        "type": "any"
      }
    ],
    "infix": "in",
    "result": {
      "type": "boolean"
    }
  },
  "internal.member_3": {
    "args": [
      {
        "type": "any"
      },
      {
        "type": "any"
      },
      {
        "type": "any"
      }
    ],
    "infix": "in",
    "result": {
      "type": "boolean"
    }
  },
  "internal.print": {
    "args": [
      {
        "type": "array[set[any]]"
      }
    ],
    "result": {}
  },
  "internal.test_case": {
    "args": [
      {
        "type": "array[any]"
      }
    ],
    "result": {}
  },
  "intersection": {
    "args": [
      {
        "description": "set of sets to intersect",
        "name": "xs",
        "type": "set[set[any]]"
      }
    ],
    "description": "Returns the intersection of the given input sets.",
    "result": {
      "description": "the intersection of all `xs` sets",
      "name": "y",
      "type": "set[any]"
    }
  },
  "io.jwt.decode": {
    "args": [
      {
        "description": "JWT token to decode",
        "name": "jwt",
        "type": "string"
      }
    ],
    "description": "Decodes a JSON Web Token and outputs it as an object.",
    "result": {
      "description": "`[header, payload, sig]`, where `header` and `payload` are objects; `sig` is the hexadecimal representation of the signature on the token.",
      "name": "output",
      "type": "array\u003cobject[any: any], object[any: any], string\u003e"
    }
  },
  "io.jwt.decode_verify": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified and whose claims are to be checked",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "claim verification constraints",
        "name": "constraints",
        "type": "object[string: any]"
      }
    ],
    "description": "Verifies a JWT signature under parameterized constraints and decodes the claims if it is valid.\nSupports the following algorithms: HS256, HS384, HS512, RS256, RS384, RS512, ES256, ES384, ES512, PS256, PS384 and PS512.",
    "result": {
      "description": "`[valid, header, payload]`:  if the input token is verified and meets the requirements of `constraints` then `valid` is `true`; `header` and `payload` are objects containing the JOSE header and the JWT claim set; otherwise, `valid` is `false`, `header` and `payload` are `{}`",
      "name": "output",
      "type": "array\u003cboolean, object[any: any], object[any: any]\u003e"
    }
  },
  "io.jwt.encode_sign": {
    "args": [
      {
        "description": "JWS Protected Header",
        "name": "headers",
        "type": "object[string: any]"
      },
      {
        "description": "JWS Payload",
        "name": "payload",
        "type": "object[string: any]"
      },
      {
        "description": "JSON Web Key (RFC7517)",
        "name": "key",
        "type": "object[string: any]"
      }
    ],
    "description": "Encodes and optionally signs a JSON Web Token. Inputs are taken as objects, not encoded strings (see `io.jwt.encode_sign_raw`).",
    "result": {
      "description": "signed JWT",
      "name": "output",
      "type": "string"
    }
  },
  "io.jwt.encode_sign_raw": {
    "args": [
      {
        "description": "JWS Protected Header",
        "name": "headers",
        "type": "string"
      },
      {
        "description": "JWS Payload",
        "name": "payload",
        "type": "string"
      },
      {
        "description": "JSON Web Key (RFC7517)",
        "name": "key",
        "type": "string"
      }
    ],
    "description": "Encodes and optionally signs a JSON Web Token.",
    "result": {
      "description": "signed JWT",
      "name": "output",
      "type": "string"
    }
  },
  "io.jwt.verify_es256": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "description": "Verifies if a ES256 JWT signature is valid.",
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_es384": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "description": "Verifies if a ES384 JWT signature is valid.",
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_es512": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "description": "Verifies if a ES512 JWT signature is valid.",
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_hs256": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "plain text secret used to verify the signature",
        "name": "secret",
        "type": "string"
      }
    ],
    "description": "Verifies if a HS256 (secret) JWT signature is valid.",
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_hs384": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "plain text secret used to verify the signature",
        "name": "secret",
        "type": "string"
      }
    ],
    "description": "Verifies if a HS384 (secret) JWT signature is valid.",
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_hs512": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "plain text secret used to verify the signature",
        "name": "secret",
        "type": "string"
      }
    ],
    "description": "Verifies if a HS512 (secret) JWT signature is valid.",
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_ps256": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "description": "Verifies if a PS256 JWT signature is valid.",
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_ps384": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "description": "Verifies if a PS384 JWT signature is valid.",
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_ps512": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "description": "Verifies if a PS512 JWT signature is valid.",
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_rs256": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "description": "Verifies if a RS256 JWT signature is valid.",
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_rs384": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "description": "Verifies if a RS384 JWT signature is valid.",
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "io.jwt.verify_rs512": {
    "args": [
      {
        "description": "JWT token whose signature is to be verified",
        "name": "jwt",
        "type": "string"
      },
      {
        "description": "PEM encoded certificate, PEM encoded public key, or the JWK key (set) used to verify the signature",
        "name": "certificate",
        "type": "string"
      }
    ],
    "description": "Verifies if a RS512 JWT signature is valid.",
    "result": {
      "description": "`true` if the signature is valid, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "is_array": {
    "args": [
      {
        "description": "input value",
        "name": "x",
        "type": "any"
      }
    ],
    "description": "Returns `true` if the input value is an array.",
    "result": {
      "description": "`true` if `x` is an array, `false` otherwise.",
      "name": "result",
      "type": "boolean"
    }
  },
  "is_boolean": {
    "args": [
      {
        "description": "input value",
        "name": "x",
        "type": "any"
      }
    ],
    "description": "Returns `true` if the input value is a boolean.",
    "result": {
      "description": "`true` if `x` is an boolean, `false` otherwise.",
      "name": "result",
      "type": "boolean"
    }
  },
  "is_null": {
    "args": [
      {
        "description": "input value",
        "name": "x",
        "type": "any"
      }
    ],
    "description": "Returns `true` if the input value is null.",
    "result": {
      "description": "`true` if `x` is null, `false` otherwise.",
      "name": "result",
      "type": "boolean"
    }
  },
  "is_number": {
    "args": [
      {
        "description": "input value",
        "name": "x",
        "type": "any"
      }
    ],
    "description": "Returns `true` if the input value is a number.",
    "result": {
      "description": "`true` if `x` is a number, `false` otherwise.",
      "name": "result",
      "type": "boolean"
    }
  },
  "is_object": {
    "args": [
      {
        "description": "input value",
        "name": "x",
        "type": "any"
      }
    ],
    "description": "Returns true if the input value is an object",
    "result": {
      "description": "`true` if `x` is an object, `false` otherwise.",
      "name": "result",
      "type": "boolean"
    }
  },
  "is_set": {
    "args": [
      {
        "description": "input value",
        "name": "x",
        "type": "any"
      }
    ],
    "description": "Returns `true` if the input value is a set.",
    "result": {
      "description": "`true` if `x` is a set, `false` otherwise.",
      "name": "result",
      "type": "boolean"
    }
  },
  "is_string": {
    "args": [
      {
        "description": "input value",
        "name": "x",
        "type": "any"
      }
    ],
    "description": "Returns `true` if the input value is a string.",
    "result": {
      "description": "`true` if `x` is a string, `false` otherwise.",
      "name": "result",
      "type": "boolean"
    }
  },
  "json.filter": {
    "args": [
      {
        "description": "object to filter",
        "name": "object",
        "type": "object[any: any]"
      },
      {
        "description": "JSON string paths",
        "name": "paths",
        "type": "any\u003carray[any\u003cstring, array[any]\u003e], set[any\u003cstring, array[any]\u003e]\u003e"
      }
    ],
    "description": "Filters the object. For example: `json.filter({\"a\": {\"b\": \"x\", \"c\": \"y\"}}, [\"a/b\"])` will result in `{\"a\": {\"b\": \"x\"}}`). Paths are not filtered in-order and are deduplicated before being evaluated.",
    "result": {
      "description": "remaining data from `object` with only keys specified in `paths`",
      "name": "filtered",
      "type": "any"
    }
  },
  "json.is_valid": {
    "args": [
      {
        "description": "a JSON string",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Verifies the input string is a valid JSON document.",
    "result": {
      "description": "`true` if `x` is valid JSON, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "json.marshal": {
    "args": [
      {
        "description": "the term to serialize",
        "name": "x",
        "type": "any"
      }
    ],
    "description": "Serializes the input term to JSON.",
    "result": {
      "description": "the JSON string representation of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "json.marshal_with_options": {
    "args": [
      {
        "description": "the term to serialize",
        "name": "x",
        "type": "any"
      },
      {
        "description": "encoding options",
        "name": "opts",
        "type": "object\u003cindent: string, prefix: string, pretty: boolean\u003e[string: any]"
      }
    ],
    "description": "Serializes the input term JSON, with additional formatting options via the `opts` parameter. `opts` accepts keys `pretty` (enable multi-line/formatted JSON), `prefix` (string to prefix lines with, default empty string) and `indent` (string to indent with, default `\\t`).",
    "result": {
      "description": "the JSON string representation of `x`, with configured prefix/indent string(s) as appropriate",
      "name": "y",
      "type": "string"
    }
  },
  "json.match_schema": {
    "args": [
      {
        "description": "document to verify by schema",
        "name": "document",
        "type": "any\u003cstring, object[any: any]\u003e"
      },
      {
        "description": "schema to verify document by",
        "name": "schema",
        "type": "any\u003cstring, object[any: any]\u003e"
      }
    ],
    "description": "Checks that the document matches the JSON schema.",
    "result": {
      "description": "`output` is of the form `[match, errors]`. If the document is valid given the schema, then `match` is `true`, and `errors` is an empty array. Otherwise, `match` is `false` and `errors` is an array of objects describing the error(s).",
      "name": "output",
      "type": "array\u003cboolean, array[object\u003cdesc: string, error: string, field: string, type: string\u003e]\u003e"
    }
  },
  "json.patch": {
    "args": [
      {
        "description": "the object to patch",
        "name": "object",
        "type": "any"
      },
      {
        "description": "the JSON patches to apply",
        "name": "patches",
        "type": "array[object\u003cop: string, path: any\u003e[any: any]]"
      }
    ],
    "description": "Patches an object according to RFC6902. For example: `json.patch({\"a\": {\"foo\": 1}}, [{\"op\": \"add\", \"path\": \"/a/bar\", \"value\": 2}])` results in `{\"a\": {\"foo\": 1, \"bar\": 2}`. The patches are applied atomically: if any of them fails, the result will be undefined. Additionally works on sets, where a value contained in the set is considered to be its path.",
    "result": {
      "description": "result obtained after consecutively applying all patch operations in `patches`",
      "name": "output",
      "type": "any"
    }
  },
  "json.remove": {
    "args": [
      {
        "description": "object to remove paths from",
        "name": "object",
        "type": "object[any: any]"
      },
      {
        "description": "JSON string paths",
        "name": "paths",
        "type": "any\u003carray[any\u003cstring, array[any]\u003e], set[any\u003cstring, array[any]\u003e]\u003e"
      }
    ],
    "description": "Removes paths from an object. For example: `json.remove({\"a\": {\"b\": \"x\", \"c\": \"y\"}}, [\"a/b\"])` will result in `{\"a\": {\"c\": \"y\"}}`. Paths are not removed in-order and are deduplicated before being evaluated.",
    "result": {
      "description": "result of removing all keys specified in `paths`",
      "name": "output",
      "type": "any"
    }
  },
  "json.unmarshal": {
    "args": [
      {
        "description": "a JSON string",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Deserializes the input string.",
    "result": {
      "description": "the term deserialized from `x`",
      "name": "y",
      "type": "any"
    }
  },
  "json.verify_schema": {
    "args": [
      {
        "description": "the schema to verify",
        "name": "schema",
        "type": "any\u003cstring, object[any: any]\u003e"
      }
    ],
    "description": "Checks that the input is a valid JSON schema object. The schema can be either a JSON string or an JSON object.",
    "result": {
      "description": "`output` is of the form `[valid, error]`. If the schema is valid, then `valid` is `true`, and `error` is `null`. Otherwise, `valid` is `false` and `error` is a string describing the error.",
      "name": "output",
      "type": "array\u003cboolean, any\u003cnull, string\u003e\u003e"
    }
  },
  "lower": {
    "args": [
      {
        "description": "string that is converted to lower-case",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Returns the input string but with all characters in lower-case.",
    "result": {
      "description": "lower-case of x",
      "name": "y",
      "type": "string"
    }
  },
  "lt": {
    "args": [
      {
        "name": "x",
        "type": "any"
      },
      {
        "name": "y",
        "type": "any"
      }
    ],
    "infix": "\u003c",
    "result": {
      "description": "true if `x` is less than `y`; false otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "lte": {
    "args": [
      {
        "name": "x",
        "type": "any"
      },
      {
        "name": "y",
        "type": "any"
      }
    ],
    "infix": "\u003c=",
    "result": {
      "description": "true if `x` is less than or equal to `y`; false otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "max": {
    "args": [
      {
        "description": "the set or array to be searched",
        "name": "collection",
        "type": "any\u003carray[any], set[any]\u003e"
      }
    ],
    "description": "Returns the maximum value in a collection.",
    "result": {
      "description": "the maximum of all elements",
      "name": "n",
      "type": "any"
    }
  },
  "min": {
    "args": [
      {
        "description": "the set or array to be searched",
        "name": "collection",
        "type": "any\u003carray[any], set[any]\u003e"
      }
    ],
    "description": "Returns the minimum value in a collection.",
    "result": {
      "description": "the minimum of all elements",
      "name": "n",
      "type": "any"
    }
  },
  "minus": {
    "args": [
      {
        "name": "x",
        "type": "any\u003cnumber, set[any]\u003e"
      },
      {
        "name": "y",
        "type": "any\u003cnumber, set[any]\u003e"
      }
    ],
    "description": "Minus subtracts the second number from the first number or computes the difference between two sets.",
    "infix": "-",
    "result": {
      "description": "the difference of `x` and `y`",
      "name": "z",
      "type": "any\u003cnumber, set[any]\u003e"
    }
  },
  "mongodb.find": {
    "args": [
      {
        "description": "query object",
        "name": "request",
        "type": "object[string: any]"
      }
    ],
    "description": "Returns query result rows to the given MongoDB operation.",
    "result": {
      "description": "query result rows",
      "name": "response",
      "type": "object[any: any]"
    }
  },
  "mongodb.find_one": {
    "args": [
      {
        "description": "query object",
        "name": "request",
        "type": "object[string: any]"
      }
    ],
    "description": "Returns query result row to the given MongoDB operation.",
    "result": {
      "description": "query result rows",
      "name": "response",
      "type": "object[any: any]"
    }
  },
  "mul": {
    "args": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      }
    ],
    "description": "Multiplies two numbers.",
    "infix": "*",
    "result": {
      "description": "the product of `x` and `y`",
      "name": "z",
      "type": "number"
    }
  },
  "neo4j.query": {
    "args": [
      {
        "description": "query object",
        "name": "request",
        "type": "object[string: any]"
      }
    ],
    "description": "Returns results for the given neo4j query.",
    "result": {
      "description": "response object",
      "name": "response",
      "type": "object[any: any]"
    }
  },
  "neq": {
    "args": [
      {
        "name": "x",
        "type": "any"
      },
      {
        "name": "y",
        "type": "any"
      }
    ],
    "infix": "!=",
    "result": {
      "description": "true if `x` is not equal to `y`; false otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "net.cidr_contains": {
    "args": [
      {
        "description": "CIDR to check against",
        "name": "cidr",
        "type": "string"
      },
      {
        "description": "CIDR or IP to check",
        "name": "cidr_or_ip",
        "type": "string"
      }
    ],
    "description": "Checks if a CIDR or IP is contained within another CIDR. `output` is `true` if `cidr_or_ip` (e.g. `127.0.0.64/26` or `127.0.0.1`) is contained within `cidr` (e.g. `127.0.0.1/24`) and `false` otherwise. Supports both IPv4 and IPv6 notations.",
    "result": {
      "description": "`true` if `cidr_or_ip` is contained within `cidr`",
      "name": "result",
      "type": "boolean"
    }
  },
  "net.cidr_contains_matches": {
    "args": [
      {
        "description": "CIDRs to check against",
        "name": "cidrs",
        "type": "any\u003cstring, array[any\u003cstring, array[any]\u003e], object[string: any\u003cstring, array[any]\u003e], set[any\u003cstring, array[any]\u003e]\u003e"
      },
      {
        "description": "CIDRs or IPs to check",
        "name": "cidrs_or_ips",
        "type": "any\u003cstring, array[any\u003cstring, array[any]\u003e], object[string: any\u003cstring, array[any]\u003e], set[any\u003cstring, array[any]\u003e]\u003e"
      }
    ],
    "description": "Checks if collections of cidrs or ips are contained within another collection of cidrs and returns matches. This function is similar to `net.cidr_contains` except it allows callers to pass collections of CIDRs or IPs as arguments and returns the matches (as opposed to a boolean result indicating a match between two CIDRs/IPs).",
    "result": {
      "description": "tuples identifying matches where `cidrs_or_ips` are contained within `cidrs`",
      "name": "output",
      "type": "set[array\u003cany, any\u003e]"
    }
  },
  "net.cidr_expand": {
    "args": [
      {
        "description": "CIDR to expand",
        "name": "cidr",
        "type": "string"
      }
    ],
    "description": "Expands CIDR to set of hosts  (e.g., `net.cidr_expand(\"192.168.0.0/30\")` generates 4 hosts: `{\"192.168.0.0\", \"192.168.0.1\", \"192.168.0.2\", \"192.168.0.3\"}`).",
    "result": {
      "description": "set of IP addresses the CIDR `cidr` expands to",
      "name": "hosts",
      "type": "set[string]"
    }
  },
  "net.cidr_intersects": {
    "args": [
      {
        "description": "first CIDR",
        "name": "cidr1",
        "type": "string"
      },
      {
        "description": "second CIDR",
        "name": "cidr2",
        "type": "string"
      }
    ],
    "description": "Checks if a CIDR intersects with another CIDR (e.g. `192.168.0.0/16` overlaps with `192.168.1.0/24`). Supports both IPv4 and IPv6 notations.",
    "result": {
      "description": "`true` if `cidr1` intersects with `cidr2`",
      "name": "result",
      "type": "boolean"
    }
  },
  "net.cidr_is_valid": {
    "args": [
      {
        "description": "CIDR to validate",
        "name": "cidr",
        "type": "string"
      }
    ],
    "description": "Parses an IPv4/IPv6 CIDR and returns a boolean indicating if the provided CIDR is valid.",
    "result": {
      "description": "`true` if `cidr` is a valid CIDR",
      "name": "result",
      "type": "boolean"
    }
  },
  "net.cidr_merge": {
    "args": [
      {
        "description": "CIDRs or IP addresses",
        "name": "addrs",
        "type": "any\u003carray[any\u003cstring\u003e], set[string]\u003e"
      }
    ],
    "description": "Merges IP addresses and subnets into the smallest possible list of CIDRs (e.g., `net.cidr_merge([\"192.0.128.0/24\", \"192.0.129.0/24\"])` generates `{\"192.0.128.0/23\"}`.This function merges adjacent subnets where possible, those contained within others and also removes any duplicates.\nSupports both IPv4 and IPv6 notations. IPv6 inputs need a prefix length (e.g. \"/128\").",
    "result": {
      "description": "smallest possible set of CIDRs obtained after merging the provided list of IP addresses and subnets in `addrs`",
      "name": "output",
      "type": "set[string]"
    }
  },
  "net.cidr_overlap": {
    "args": [
      {
        "type": "string"
      },
      {
        "type": "string"
      }
    ],
    "deprecated": true,
    "result": {
      "type": "boolean"
    }
  },
  "net.lookup_ip_addr": {
    "args": [
      {
        "description": "domain name to resolve",
        "name": "name",
        "type": "string"
      }
    ],
    "description": "Returns the set of IP addresses (both v4 and v6) that the passed-in `name` resolves to using the standard name resolution mechanisms available.",
    "result": {
      "description": "IP addresses (v4 and v6) that `name` resolves to",
      "name": "addrs",
      "type": "set[string]"
    }
  },
  "numbers.range": {
    "args": [
      {
        "description": "the start of the range",
        "name": "a",
        "type": "number"
      },
      {
        "description": "the end of the range (inclusive)",
        "name": "b",
        "type": "number"
      }
    ],
    "description": "Returns an array of numbers in the given (inclusive) range. If `a==b`, then `range == [a]`; if `a \u003e b`, then `range` is in descending order.",
    "result": {
      "description": "the range between `a` and `b`",
      "name": "range",
      "type": "array[number]"
    }
  },
  "numbers.range_step": {
    "args": [
      {
        "description": "the start of the range",
        "name": "a",
        "type": "number"
      },
      {
        "description": "the end of the range (inclusive)",
        "name": "b",
        "type": "number"
      },
      {
        "description": "the step between numbers in the range",
        "name": "step",
        "type": "number"
      }
    ],
    "description": "Returns an array of numbers in the given (inclusive) range incremented by a positive step.\n\tIf \"a==b\", then \"range == [a]\"; if \"a \u003e b\", then \"range\" is in descending order.\n\tIf the provided \"step\" is less then 1, an error will be thrown.\n\tIf \"b\" is not in the range of the provided \"step\", \"b\" won't be included in the result.\n\t",
    "result": {
      "description": "the range between `a` and `b` in `step` increments",
      "name": "range",
      "type": "array[number]"
    }
  },
  "object.filter": {
    "args": [
      {
        "description": "object to filter keys",
        "name": "object",
        "type": "object[any: any]"
      },
      {
        "description": "keys to keep in `object`",
        "name": "keys",
        "type": "any\u003carray[any], object[any: any], set[any]\u003e"
      }
    ],
    "description": "Filters the object by keeping only specified keys. For example: `object.filter({\"a\": {\"b\": \"x\", \"c\": \"y\"}, \"d\": \"z\"}, [\"a\"])` will result in `{\"a\": {\"b\": \"x\", \"c\": \"y\"}}`).",
    "result": {
      "description": "remaining data from `object` with only keys specified in `keys`",
      "name": "filtered",
      "type": "any"
    }
  },
  "object.get": {
    "args": [
      {
        "description": "object to get `key` from",
        "name": "object",
        "type": "object[any: any]"
      },
      {
        "description": "key to lookup in `object`",
        "name": "key",
        "type": "any"
      },
      {
        "description": "default to use when lookup fails",
        "name": "default",
        "type": "any"
      }
    ],
    "description": "Returns value of an object's key if present, otherwise a default. If the supplied `key` is an `array`, then `object.get` will search through a nested object or array using each key in turn. For example: `object.get({\"a\": [{ \"b\": true }]}, [\"a\", 0, \"b\"], false)` results in `true`.",
    "result": {
      "description": "`object[key]` if present, otherwise `default`",
      "name": "value",
      "type": "any"
    }
  },
  "object.keys": {
    "args": [
      {
        "description": "object to get keys from",
        "name": "object",
        "type": "object[any: any]"
      }
    ],
    "description": "Returns a set of an object's keys. For example: `object.keys({\"a\": 1, \"b\": true, \"c\": \"d\")` results in `{\"a\", \"b\", \"c\"}`.",
    "result": {
      "description": "set of `object`'s keys",
      "name": "value",
      "type": "set[any]"
    }
  },
  "object.remove": {
    "args": [
      {
        "description": "object to remove keys from",
        "name": "object",
        "type": "object[any: any]"
      },
      {
        "description": "keys to remove from x",
        "name": "keys",
        "type": "any\u003carray[any], object[any: any], set[any]\u003e"
      }
    ],
    "description": "Removes specified keys from an object.",
    "result": {
      "description": "result of removing the specified `keys` from `object`",
      "name": "output",
      "type": "any"
    }
  },
  "object.subset": {
    "args": [
      {
        "description": "object to test if sub is a subset of",
        "name": "super",
        "type": "any\u003carray[any], object[any: any], set[any]\u003e"
      },
      {
        "description": "object to test if super is a superset of",
        "name": "sub",
        "type": "any\u003carray[any], object[any: any], set[any]\u003e"
      }
    ],
    "description": "Determines if an object `sub` is a subset of another object `super`.Object `sub` is a subset of object `super` if and only if every key in `sub` is also in `super`, **and** for all keys which `sub` and `super` share, they have the same value. This function works with objects, sets, arrays and a set of array and set.If both arguments are objects, then the operation is recursive, e.g. `{\"c\": {\"x\": {10, 15, 20}}` is a subset of `{\"a\": \"b\", \"c\": {\"x\": {10, 15, 20, 25}, \"y\": \"z\"}`. If both arguments are sets, then this function checks if every element of `sub` is a member of `super`, but does not attempt to recurse. If both arguments are arrays, then this function checks if `sub` appears contiguously in order within `super`, and also does not attempt to recurse. If `super` is array and `sub` is set, then this function checks if `super` contains every element of `sub` with no consideration of ordering, and also does not attempt to recurse.",
    "result": {
      "description": "`true` if `sub` is a subset of `super`",
      "name": "result",
      "type": "any"
    }
  },
  "object.union": {
    "args": [
      {
        "description": "left-hand object",
        "name": "a",
        "type": "object[any: any]"
      },
      {
        "description": "right-hand object",
        "name": "b",
        "type": "object[any: any]"
      }
    ],
    "description": "Creates a new object of the asymmetric union of two objects. For example: `object.union({\"a\": 1, \"b\": 2, \"c\": {\"d\": 3}}, {\"a\": 7, \"c\": {\"d\": 4, \"e\": 5}})` will result in `{\"a\": 7, \"b\": 2, \"c\": {\"d\": 4, \"e\": 5}}`.",
    "result": {
      "description": "a new object which is the result of an asymmetric recursive union of two objects where conflicts are resolved by choosing the key from the right-hand object `b`",
      "name": "output",
      "type": "any"
    }
  },
  "object.union_n": {
    "args": [
      {
        "description": "list of objects to merge",
        "name": "objects",
        "type": "array[object[any: any]]"
      }
    ],
    "description": "Creates a new object that is the asymmetric union of all objects merged from left to right. For example: `object.union_n([{\"a\": 1}, {\"b\": 2}, {\"a\": 3}])` will result in `{\"b\": 2, \"a\": 3}`.",
    "result": {
      "description": "asymmetric recursive union of all objects in `objects`, merged from left to right, where conflicts are resolved by choosing the key from the right-hand object",
      "name": "output",
      "type": "any"
    }
  },
  "opa.runtime": {
    "args": [],
    "description": "Returns an object that describes the runtime environment where OPA is deployed.",
    "result": {
      "description": "includes a `config` key if OPA was started with a configuration file; an `env` key containing the environment variables that the OPA process was started with; includes `version` and `commit` keys containing the version and build commit of OPA.",
      "name": "output",
      "type": "object[string: any]"
    }
  },
  "or": {
    "args": [
      {
        "name": "x",
        "type": "set[any]"
      },
      {
        "name": "y",
        "type": "set[any]"
      }
    ],
    "description": "Returns the union of two sets.",
    "infix": "|",
    "result": {
      "description": "the union of `x` and `y`",
      "name": "z",
      "type": "set[any]"
    }
  },
  "plus": {
    "args": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      }
    ],
    "description": "Plus adds two numbers together.",
    "infix": "+",
    "result": {
      "description": "the sum of `x` and `y`",
      "name": "z",
      "type": "number"
    }
  },
  "print": {
    "args": [],
    "result": {}
  },
  "product": {
    "args": [
      {
        "description": "the set or array of numbers to multiply",
        "name": "collection",
        "type": "any\u003carray[number], set[number]\u003e"
      }
    ],
    "description": "Multiplies elements of an array or set of numbers",
    "result": {
      "description": "the product of all elements",
      "name": "n",
      "type": "number"
    }
  },
  "providers.aws.sign_req": {
    "args": [
      {
        "description": "HTTP request object",
        "name": "request",
        "type": "object[string: any]"
      },
      {
        "description": "AWS configuration object",
        "name": "aws_config",
        "type": "object[string: any]"
      },
      {
        "description": "nanoseconds since the epoch",
        "name": "time_ns",
        "type": "number"
      }
    ],
    "description": "Signs an HTTP request object for Amazon Web Services. Currently implements [AWS Signature Version 4 request signing](https://docs.aws.amazon.com/AmazonS3/latest/API/sig-v4-authenticating-requests.html) by the `Authorization` header method.",
    "result": {
      "description": "HTTP request object with `Authorization` header",
      "name": "signed_request",
      "type": "object[any: any]"
    }
  },
  "rand.intn": {
    "args": [
      {
        "description": "seed string for the random number",
        "name": "str",
        "type": "string"
      },
      {
        "description": "upper bound of the random number (exclusive)",
        "name": "n",
        "type": "number"
      }
    ],
    "description": "Returns a random integer between `0` and `n` (`n` exclusive). If `n` is `0`, then `y` is always `0`. For any given argument pair (`str`, `n`), the output will be consistent throughout a query evaluation.",
    "result": {
      "description": "random integer in the range `[0, abs(n))`",
      "name": "y",
      "type": "number"
    }
  },
  "re_match": {
    "args": [
      {
        "type": "string"
      },
      {
        "type": "string"
      }
    ],
    "deprecated": true,
    "result": {
      "type": "boolean"
    }
  },
  "redis.query": {
    "args": [
      {
        "description": "query object",
        "name": "request",
        "type": "object[string: any]"
      }
    ],
    "description": "Returns the result of the given Redis command.",
    "result": {
      "description": "response object",
      "name": "response",
      "type": "object[any: any]"
    }
  },
  "regex.find_all_string_submatch_n": {
    "args": [
      {
        "description": "regular expression",
        "name": "pattern",
        "type": "string"
      },
      {
        "description": "string to match",
        "name": "value",
        "type": "string"
      },
      {
        "description": "number of matches to return; `-1` means all matches",
        "name": "number",
        "type": "number"
      }
    ],
    "description": "Returns all successive matches of the expression.",
    "result": {
      "description": "array of all matches",
      "name": "output",
      "type": "array[array[string]]"
    }
  },
  "regex.find_n": {
    "args": [
      {
        "description": "regular expression",
        "name": "pattern",
        "type": "string"
      },
      {
        "description": "string to match",
        "name": "value",
        "type": "string"
      },
      {
        "description": "number of matches to return, if `-1`, returns all matches",
        "name": "number",
        "type": "number"
      }
    ],
    "description": "Returns the specified number of matches when matching the input against the pattern.",
    "result": {
      "description": "collected matches",
      "name": "output",
      "type": "array[string]"
    }
  },
  "regex.globs_match": {
    "args": [
      {
        "description": "first glob-style regular expression",
        "name": "glob1",
        "type": "string"
      },
      {
        "description": "second glob-style regular expression",
        "name": "glob2",
        "type": "string"
      }
    ],
    "description": "Checks if the intersection of two glob-style regular expressions matches a non-empty set of non-empty strings.\nThe set of regex symbols is limited for this builtin: only `.`, `*`, `+`, `[`, `-`, `]` and `\\` are treated as special symbols.",
    "result": {
      "description": "true if the intersection of `glob1` and `glob2` matches a non-empty set of non-empty strings",
      "name": "result",
      "type": "boolean"
    }
  },
  "regex.is_valid": {
    "args": [
      {
        "description": "regular expression",
        "name": "pattern",
        "type": "string"
      }
    ],
    "description": "Checks if a string is a valid regular expression: the detailed syntax for patterns is defined by https://github.com/google/re2/wiki/Syntax.",
    "result": {
      "description": "true if `pattern` is a valid regular expression",
      "name": "result",
      "type": "boolean"
    }
  },
  "regex.match": {
    "args": [
      {
        "description": "regular expression",
        "name": "pattern",
        "type": "string"
      },
      {
        "description": "value to match against `pattern`",
        "name": "value",
        "type": "string"
      }
    ],
    "description": "Matches a string against a regular expression.",
    "result": {
      "description": "true if `value` matches `pattern`",
      "name": "result",
      "type": "boolean"
    }
  },
  "regex.replace": {
    "args": [
      {
        "description": "string being processed",
        "name": "s",
        "type": "string"
      },
      {
        "description": "regex pattern to be applied",
        "name": "pattern",
        "type": "string"
      },
      {
        "description": "regex value",
        "name": "value",
        "type": "string"
      }
    ],
    "description": "Find and replaces the text using the regular expression pattern.",
    "result": {
      "description": "string with replaced substrings",
      "name": "output",
      "type": "string"
    }
  },
  "regex.split": {
    "args": [
      {
        "description": "regular expression",
        "name": "pattern",
        "type": "string"
      },
      {
        "description": "string to match",
        "name": "value",
        "type": "string"
      }
    ],
    "description": "Splits the input string by the occurrences of the given pattern.",
    "result": {
      "description": "the parts obtained by splitting `value`",
      "name": "output",
      "type": "array[string]"
    }
  },
  "regex.template_match": {
    "args": [
      {
        "description": "template expression containing `0..n` regular expressions",
        "name": "template",
        "type": "string"
      },
      {
        "description": "string to match",
        "name": "value",
        "type": "string"
      },
      {
        "description": "start delimiter of the regular expression in `template`",
        "name": "delimiter_start",
        "type": "string"
      },
      {
        "description": "end delimiter of the regular expression in `template`",
        "name": "delimiter_end",
        "type": "string"
      }
    ],
    "description": "Matches a string against a pattern, where there pattern may be glob-like",
    "result": {
      "description": "true if `value` matches the `template`",
      "name": "result",
      "type": "boolean"
    }
  },
  "rego.compile": {
    "args": [
      {
        "description": "rego compile request",
        "name": "request",
        "type": "object[string: any]"
      }
    ],
    "result": {
      "description": "rego compile result",
      "name": "output",
      "type": "object[any: any]"
    }
  },
  "rego.eval": {
    "args": [
      {
        "description": "rego eval request",
        "name": "request",
        "type": "object[string: any]"
      }
    ],
    "result": {
      "description": "rego eval result",
      "name": "output",
      "type": "object[any: any]"
    }
  },
  "rego.metadata.chain": {
    "args": [],
    "description": "Returns the chain of metadata for the active rule.\nOrdered starting at the active rule, going outward to the most distant node in its package ancestry.\nA chain entry is a JSON document with two members: \"path\", an array representing the path of the node; and \"annotations\", a JSON document containing the annotations declared for the node.\nThe first entry in the chain always points to the active rule, even if it has no declared annotations (in which case the \"annotations\" member is not present).",
    "result": {
      "description": "each array entry represents a node in the path ancestry (chain) of the active rule that also has declared annotations",
      "name": "chain",
      "type": "array[any]"
    }
  },
  "rego.metadata.rule": {
    "args": [],
    "description": "Returns annotations declared for the active rule and using the _rule_ scope.",
    "result": {
      "description": "\"rule\" scope annotations for this rule; empty object if no annotations exist",
      "name": "output",
      "type": "any"
    }
  },
  "rego.parse_module": {
    "args": [
      {
        "description": "file name to attach to AST nodes' locations",
        "name": "filename",
        "type": "string"
      },
      {
        "description": "Rego module",
        "name": "rego",
        "type": "string"
      }
    ],
    "description": "Parses the input Rego string and returns an object representation of the AST.",
    "result": {
      "description": "AST object for the Rego module",
      "name": "output",
      "type": "object[string: any]"
    }
  },
  "rem": {
    "args": [
      {
        "name": "x",
        "type": "number"
      },
      {
        "name": "y",
        "type": "number"
      }
    ],
    "description": "Returns the remainder for of `x` divided by `y`, for `y != 0`.",
    "infix": "%",
    "result": {
      "description": "the remainder",
      "name": "z",
      "type": "number"
    }
  },
  "replace": {
    "args": [
      {
        "description": "string being processed",
        "name": "x",
        "type": "string"
      },
      {
        "description": "substring to replace",
        "name": "old",
        "type": "string"
      },
      {
        "description": "string to replace `old` with",
        "name": "new",
        "type": "string"
      }
    ],
    "description": "Replace replaces all instances of a sub-string.",
    "result": {
      "description": "string with replaced substrings",
      "name": "y",
      "type": "string"
    }
  },
  "round": {
    "args": [
      {
        "description": "the number to round",
        "name": "x",
        "type": "number"
      }
    ],
    "description": "Rounds the number to the nearest integer.",
    "result": {
      "description": "the result of rounding `x`",
      "name": "y",
      "type": "number"
    }
  },
  "semver.compare": {
    "args": [
      {
        "description": "first version string",
        "name": "a",
        "type": "string"
      },
      {
        "description": "second version string",
        "name": "b",
        "type": "string"
      }
    ],
    "description": "Compares valid SemVer formatted version strings.",
    "result": {
      "description": "`-1` if `a \u003c b`; `1` if `a \u003e b`; `0` if `a == b`",
      "name": "result",
      "type": "number"
    }
  },
  "semver.is_valid": {
    "args": [
      {
        "description": "input to validate",
        "name": "vsn",
        "type": "any"
      }
    ],
    "description": "Validates that the input is a valid SemVer string.",
    "result": {
      "description": "`true` if `vsn` is a valid SemVer; `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "set_diff": {
    "args": [
      {
        "type": "set[any]"
      },
      {
        "type": "set[any]"
      }
    ],
    "deprecated": true,
    "result": {
      "type": "set[any]"
    }
  },
  "sort": {
    "args": [
      {
        "description": "the array or set to be sorted",
        "name": "collection",
        "type": "any\u003carray[any], set[any]\u003e"
      }
    ],
    "description": "Returns a sorted array.",
    "result": {
      "description": "the sorted array",
      "name": "n",
      "type": "array[any]"
    }
  },
  "split": {
    "args": [
      {
        "description": "string that is split",
        "name": "x",
        "type": "string"
      },
      {
        "description": "delimiter used for splitting",
        "name": "delimiter",
        "type": "string"
      }
    ],
    "description": "Split returns an array containing elements of the input string split on a delimiter.",
    "result": {
      "description": "split parts",
      "name": "ys",
      "type": "array[string]"
    }
  },
  "sprintf": {
    "args": [
      {
        "description": "string with formatting verbs",
        "name": "format",
        "type": "string"
      },
      {
        "description": "arguments to format into formatting verbs",
        "name": "values",
        "type": "array[any]"
      }
    ],
    "description": "Returns the given string, formatted.",
    "result": {
      "description": "`format` formatted by the values in `values`",
      "name": "output",
      "type": "string"
    }
  },
  "sql.send": {
    "args": [
      {
        "description": "query object",
        "name": "request",
        "type": "object[string: any]"
      }
    ],
    "description": "Returns query result rows to the given SQL query.",
    "result": {
      "description": "query result rows",
      "name": "response",
      "type": "object[any: any]"
    }
  },
  "startswith": {
    "args": [
      {
        "description": "search string",
        "name": "search",
        "type": "string"
      },
      {
        "description": "base string",
        "name": "base",
        "type": "string"
      }
    ],
    "description": "Returns true if the search string begins with the base string.",
    "result": {
      "description": "result of the prefix check",
      "name": "result",
      "type": "boolean"
    }
  },
  "strings.any_prefix_match": {
    "args": [
      {
        "description": "search string(s)",
        "name": "search",
        "type": "any\u003cstring, array[string], set[string]\u003e"
      },
      {
        "description": "base string(s)",
        "name": "base",
        "type": "any\u003cstring, array[string], set[string]\u003e"
      }
    ],
    "description": "Returns true if any of the search strings begins with any of the base strings.",
    "result": {
      "description": "result of the prefix check",
      "name": "result",
      "type": "boolean"
    }
  },
  "strings.any_suffix_match": {
    "args": [
      {
        "description": "search string(s)",
        "name": "search",
        "type": "any\u003cstring, array[string], set[string]\u003e"
      },
      {
        "description": "base string(s)",
        "name": "base",
        "type": "any\u003cstring, array[string], set[string]\u003e"
      }
    ],
    "description": "Returns true if any of the search strings ends with any of the base strings.",
    "result": {
      "description": "result of the suffix check",
      "name": "result",
      "type": "boolean"
    }
  },
  "strings.count": {
    "args": [
      {
        "description": "string to search in",
        "name": "search",
        "type": "string"
      },
      {
        "description": "substring to look for",
        "name": "substring",
        "type": "string"
      }
    ],
    "description": "Returns the number of non-overlapping instances of a substring in a string.",
    "result": {
      "description": "count of occurrences, `0` if not found",
      "name": "output",
      "type": "number"
    }
  },
  "strings.render_template": {
    "args": [
      {
        "description": "a templated string",
        "name": "value",
        "type": "string"
      },
      {
        "description": "a mapping of template variable keys to values",
        "name": "vars",
        "type": "object[string: any]"
      }
    ],
    "description": "Renders a templated string with given template variables injected. For a given templated string and key/value mapping, values will be injected into the template where they are referenced by key.\n\tFor examples of templating syntax, see https://pkg.go.dev/text/template",
    "result": {
      "description": "rendered template with template variables injected",
      "name": "result",
      "type": "string"
    }
  },
  "strings.replace_n": {
    "args": [
      {
        "description": "replacement pairs",
        "name": "patterns",
        "type": "object[string: string]"
      },
      {
        "description": "string to replace substring matches in",
        "name": "value",
        "type": "string"
      }
    ],
    "description": "Replaces a string from a list of old, new string pairs.\nReplacements are performed in the order they appear in the target string, without overlapping matches.\nThe old string comparisons are done in argument order.",
    "result": {
      "description": "string with replaced substrings",
      "name": "output",
      "type": "string"
    }
  },
  "strings.reverse": {
    "args": [
      {
        "description": "string to reverse",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Reverses a given string.",
    "result": {
      "description": "reversed string",
      "name": "y",
      "type": "string"
    }
  },
  "substring": {
    "args": [
      {
        "description": "string to extract substring from",
        "name": "value",
        "type": "string"
      },
      {
        "description": "offset, must be positive",
        "name": "offset",
        "type": "number"
      },
      {
        "description": "length of the substring starting from `offset`",
        "name": "length",
        "type": "number"
      }
    ],
    "description": "Returns the  portion of a string for a given `offset` and a `length`.  If `length \u003c 0`, `output` is the remainder of the string.",
    "result": {
      "description": "substring of `value` from `offset`, of length `length`",
      "name": "output",
      "type": "string"
    }
  },
  "sum": {
    "args": [
      {
        "description": "the set or array of numbers to sum",
        "name": "collection",
        "type": "any\u003carray[number], set[number]\u003e"
      }
    ],
    "description": "Sums elements of an array or set of numbers.",
    "result": {
      "description": "the sum of all elements",
      "name": "n",
      "type": "number"
    }
  },
  "time.add_date": {
    "args": [
      {
        "description": "nanoseconds since the epoch",
        "name": "ns",
        "type": "number"
      },
      {
        "description": "number of years to add",
        "name": "years",
        "type": "number"
      },
      {
        "description": "number of months to add",
        "name": "months",
        "type": "number"
      },
      {
        "description": "number of days to add",
        "name": "days",
        "type": "number"
      }
    ],
    "description": "Returns the nanoseconds since epoch after adding years, months and days to nanoseconds. Month \u0026 day values outside their usual ranges after the operation and will be normalized - for example, October 32 would become November 1. `undefined` if the result would be outside the valid time range that can fit within an `int64`.",
    "result": {
      "description": "nanoseconds since the epoch representing the input time, with years, months and days added",
      "name": "output",
      "type": "number"
    }
  },
  "time.clock": {
    "args": [
      {
        "description": "a number representing the nanoseconds since the epoch (UTC); or a two-element array of the nanoseconds, and a timezone string",
        "name": "x",
        "type": "any\u003cnumber, array\u003cnumber, string\u003e\u003e"
      }
    ],
    "description": "Returns the `[hour, minute, second]` of the day for the nanoseconds since epoch.",
    "result": {
      "description": "the `hour`, `minute` (0-59), and `second` (0-59) representing the time of day for the nanoseconds since epoch in the supplied timezone (or UTC)",
      "name": "output",
      "type": "array\u003cnumber, number, number\u003e"
    }
  },
  "time.date": {
    "args": [
      {
        "description": "a number representing the nanoseconds since the epoch (UTC); or a two-element array of the nanoseconds, and a timezone string",
        "name": "x",
        "type": "any\u003cnumber, array\u003cnumber, string\u003e\u003e"
      }
    ],
    "description": "Returns the `[year, month, day]` for the nanoseconds since epoch.",
    "result": {
      "description": "an array of `year`, `month` (1-12), and `day` (1-31)",
      "name": "date",
      "type": "array\u003cnumber, number, number\u003e"
    }
  },
  "time.diff": {
    "args": [
      {
        "description": "nanoseconds since the epoch; or a two-element array of the nanoseconds, and a timezone string",
        "name": "ns1",
        "type": "any\u003cnumber, array\u003cnumber, string\u003e\u003e"
      },
      {
        "description": "nanoseconds since the epoch; or a two-element array of the nanoseconds, and a timezone string",
        "name": "ns2",
        "type": "any\u003cnumber, array\u003cnumber, string\u003e\u003e"
      }
    ],
    "description": "Returns the difference between two unix timestamps in nanoseconds (with optional timezone strings).",
    "result": {
      "description": "difference between `ns1` and `ns2` (in their supplied timezones, if supplied, or UTC) as array of numbers: `[years, months, days, hours, minutes, seconds]`",
      "name": "output",
      "type": "array\u003cnumber, number, number, number, number, number\u003e"
    }
  },
  "time.format": {
    "args": [
      {
        "description": "a number representing the nanoseconds since the epoch (UTC); or a two-element array of the nanoseconds, and a timezone string; or a three-element array of ns, timezone string and a layout string or golang defined formatting constant (see golang supported time formats)",
        "name": "x",
        "type": "any\u003cnumber, array\u003cnumber, string\u003e, array\u003cnumber, string, string\u003e\u003e"
      }
    ],
    "description": "Returns the formatted timestamp for the nanoseconds since epoch.",
    "result": {
      "description": "the formatted timestamp represented for the nanoseconds since the epoch in the supplied timezone (or UTC)",
      "name": "formatted timestamp",
      "type": "string"
    }
  },
  "time.now_ns": {
    "args": [],
    "description": "Returns the current time since epoch in nanoseconds.",
    "result": {
      "description": "nanoseconds since epoch",
      "name": "now",
      "type": "number"
    }
  },
  "time.parse_duration_ns": {
    "args": [
      {
        "description": "a duration like \"3m\"; see the [Go `time` package documentation](https://golang.org/pkg/time/#ParseDuration) for more details",
        "name": "duration",
        "type": "string"
      }
    ],
    "description": "Returns the duration in nanoseconds represented by a string.",
    "result": {
      "description": "the `duration` in nanoseconds",
      "name": "ns",
      "type": "number"
    }
  },
  "time.parse_ns": {
    "args": [
      {
        "description": "format used for parsing, see the [Go `time` package documentation](https://golang.org/pkg/time/#Parse) for more details",
        "name": "layout",
        "type": "string"
      },
      {
        "description": "input to parse according to `layout`",
        "name": "value",
        "type": "string"
      }
    ],
    "description": "Returns the time in nanoseconds parsed from the string in the given format. `undefined` if the result would be outside the valid time range that can fit within an `int64`.",
    "result": {
      "description": "`value` in nanoseconds since epoch",
      "name": "ns",
      "type": "number"
    }
  },
  "time.parse_rfc3339_ns": {
    "args": [
      {
        "description": "input string to parse in RFC3339 format",
        "name": "value",
        "type": "string"
      }
    ],
    "description": "Returns the time in nanoseconds parsed from the string in RFC3339 format. `undefined` if the result would be outside the valid time range that can fit within an `int64`.",
    "result": {
      "description": "`value` in nanoseconds since epoch",
      "name": "ns",
      "type": "number"
    }
  },
  "time.weekday": {
    "args": [
      {
        "description": "a number representing the nanoseconds since the epoch (UTC); or a two-element array of the nanoseconds, and a timezone string",
        "name": "x",
        "type": "any\u003cnumber, array\u003cnumber, string\u003e\u003e"
      }
    ],
    "description": "Returns the day of the week (Monday, Tuesday, ...) for the nanoseconds since epoch.",
    "result": {
      "description": "the weekday represented by `ns` nanoseconds since the epoch in the supplied timezone (or UTC)",
      "name": "day",
      "type": "string"
    }
  },
  "to_number": {
    "args": [
      {
        "description": "value to convert",
        "name": "x",
        "type": "any\u003cnull, boolean, number, string\u003e"
      }
    ],
    "description": "Converts a string, bool, or number value to a number: Strings are converted to numbers using `strconv.Atoi`, Boolean `false` is converted to 0 and `true` is converted to 1.",
    "result": {
      "description": "the numeric representation of `x`",
      "name": "num",
      "type": "number"
    }
  },
  "trace": {
    "args": [
      {
        "description": "the note to include",
        "name": "note",
        "type": "string"
      }
    ],
    "description": "Emits `note` as a `Note` event in the query explanation. Query explanations show the exact expressions evaluated by OPA during policy execution. For example, `trace(\"Hello There!\")` includes `Note \"Hello There!\"` in the query explanation. To include variables in the message, use `sprintf`. For example, `person := \"Bob\"; trace(sprintf(\"Hello There! %v\", [person]))` will emit `Note \"Hello There! Bob\"` inside of the explanation.",
    "result": {
      "description": "always `true`",
      "name": "result",
      "type": "boolean"
    }
  },
  "trim": {
    "args": [
      {
        "description": "string to trim",
        "name": "value",
        "type": "string"
      },
      {
        "description": "string of characters that are cut off",
        "name": "cutset",
        "type": "string"
      }
    ],
    "description": "Returns `value` with all leading or trailing instances of the `cutset` characters removed.",
    "result": {
      "description": "string trimmed of `cutset` characters",
      "name": "output",
      "type": "string"
    }
  },
  "trim_left": {
    "args": [
      {
        "description": "string to trim",
        "name": "value",
        "type": "string"
      },
      {
        "description": "string of characters that are cut off on the left",
        "name": "cutset",
        "type": "string"
      }
    ],
    "description": "Returns `value` with all leading instances of the `cutset` characters removed.",
    "result": {
      "description": "string left-trimmed of `cutset` characters",
      "name": "output",
      "type": "string"
    }
  },
  "trim_prefix": {
    "args": [
      {
        "description": "string to trim",
        "name": "value",
        "type": "string"
      },
      {
        "description": "prefix to cut off",
        "name": "prefix",
        "type": "string"
      }
    ],
    "description": "Returns `value` without the prefix. If `value` doesn't start with `prefix`, it is returned unchanged.",
    "result": {
      "description": "string with `prefix` cut off",
      "name": "output",
      "type": "string"
    }
  },
  "trim_right": {
    "args": [
      {
        "description": "string to trim",
        "name": "value",
        "type": "string"
      },
      {
        "description": "string of characters that are cut off on the right",
        "name": "cutset",
        "type": "string"
      }
    ],
    "description": "Returns `value` with all trailing instances of the `cutset` characters removed.",
    "result": {
      "description": "string right-trimmed of `cutset` characters",
      "name": "output",
      "type": "string"
    }
  },
  "trim_space": {
    "args": [
      {
        "description": "string to trim",
        "name": "value",
        "type": "string"
      }
    ],
    "description": "Return the given string with all leading and trailing white space removed.",
    "result": {
      "description": "string leading and trailing white space cut off",
      "name": "output",
      "type": "string"
    }
  },
  "trim_suffix": {
    "args": [
      {
        "description": "string to trim",
        "name": "value",
        "type": "string"
      },
      {
        "description": "suffix to cut off",
        "name": "suffix",
        "type": "string"
      }
    ],
    "description": "Returns `value` without the suffix. If `value` doesn't end with `suffix`, it is returned unchanged.",
    "result": {
      "description": "string with `suffix` cut off",
      "name": "output",
      "type": "string"
    }
  },
  "type_name": {
    "args": [
      {
        "description": "input value",
        "name": "x",
        "type": "any"
      }
    ],
    "description": "Returns the type of its input value.",
    "result": {
      "description": "one of \"null\", \"boolean\", \"number\", \"string\", \"array\", \"object\", \"set\"",
      "name": "type",
      "type": "string"
    }
  },
  "union": {
    "args": [
      {
        "description": "set of sets to merge",
        "name": "xs",
        "type": "set[set[any]]"
      }
    ],
    "description": "Returns the union of the given input sets.",
    "result": {
      "description": "the union of all `xs` sets",
      "name": "y",
      "type": "set[any]"
    }
  },
  "units.parse": {
    "args": [
      {
        "description": "the unit to parse",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Converts strings like \"10G\", \"5K\", \"4M\", \"1500m\", and the like into a number.\nThis number can be a non-integer, such as 1.5, 0.22, etc. Scientific notation is supported,\nallowing values such as \"1e-3K\" (1) or \"2.5e6M\" (2.5 million M).\n\nSupports standard metric decimal and binary SI units (e.g., K, Ki, M, Mi, G, Gi, etc.) where\nm, K, M, G, T, P, and E are treated as decimal units and Ki, Mi, Gi, Ti, Pi, and Ei are treated as\nbinary units.\n\nNote that 'm' and 'M' are case-sensitive to allow distinguishing between \"milli\" and \"mega\" units\nrespectively. Other units are case-insensitive.",
    "result": {
      "description": "the parsed number",
      "name": "y",
      "type": "number"
    }
  },
  "units.parse_bytes": {
    "args": [
      {
        "description": "the byte unit to parse",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Converts strings like \"10GB\", \"5K\", \"4mb\", or \"1e6KB\" into an integer number of bytes.\n\nSupports standard byte units (e.g., KB, KiB, etc.) where KB, MB, GB, and TB are treated as decimal\nunits, and KiB, MiB, GiB, and TiB are treated as binary units. Scientific notation is supported,\nenabling values like \"1.5e3MB\" (1500MB) or \"2e6GiB\" (2 million GiB).\n\nThe bytes symbol (b/B) in the unit is optional; omitting it will yield the same result (e.g., \"Mi\"\nand \"MiB\" are equivalent).",
    "result": {
      "description": "the parsed number",
      "name": "y",
      "type": "number"
    }
  },
  "upper": {
    "args": [
      {
        "description": "string that is converted to upper-case",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Returns the input string but with all characters in upper-case.",
    "result": {
      "description": "upper-case of x",
      "name": "y",
      "type": "string"
    }
  },
  "urlquery.decode": {
    "args": [
      {
        "description": "the URL-encoded string",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Decodes a URL-encoded input string.",
    "result": {
      "description": "URL-encoding deserialization of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "urlquery.decode_object": {
    "args": [
      {
        "description": "the query string",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Decodes the given URL query string into an object.",
    "result": {
      "description": "the resulting object",
      "name": "object",
      "type": "object[string: array[string]]"
    }
  },
  "urlquery.encode": {
    "args": [
      {
        "description": "the string to encode",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Encodes the input string into a URL-encoded string.",
    "result": {
      "description": "URL-encoding serialization of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "urlquery.encode_object": {
    "args": [
      {
        "description": "the object to encode",
        "name": "object",
        "type": "object[string: any\u003cstring, array[string], set[string]\u003e]"
      }
    ],
    "description": "Encodes the given object into a URL encoded query string.",
    "result": {
      "description": "the URL-encoded serialization of `object`",
      "name": "y",
      "type": "string"
    }
  },
  "uuid.parse": {
    "args": [
      {
        "description": "UUID string to parse",
        "name": "uuid",
        "type": "string"
      }
    ],
    "description": "Parses the string value as an UUID and returns an object with the well-defined fields of the UUID if valid.",
    "result": {
      "description": "Properties of UUID if valid (version, variant, etc). Undefined otherwise.",
      "name": "result",
      "type": "object[string: any]"
    }
  },
  "uuid.rfc4122": {
    "args": [
      {
        "description": "seed string",
        "name": "k",
        "type": "string"
      }
    ],
    "description": "Returns a new UUIDv4.",
    "result": {
      "description": "a version 4 UUID; for any given `k`, the output will be consistent throughout a query evaluation",
      "name": "output",
      "type": "string"
    }
  },
  "vault.send": {
    "args": [
      {
        "description": "request object",
        "name": "request",
        "type": "object[string: any]"
      }
    ],
    "description": "Returns result to the given Vault operation.",
    "result": {
      "description": "response object",
      "name": "response",
      "type": "object[any: any]"
    }
  },
  "walk": {
    "args": [
      {
        "description": "value to walk",
        "name": "x",
        "type": "any"
      }
    ],
    "description": "Generates `[path, value]` tuples for all nested documents of `x` (recursively).  Queries can use `walk` to traverse documents nested under `x`.",
    "relation": true,
    "result": {
      "description": "pairs of `path` and `value`: `path` is an array representing the pointer to `value` in `x`. If `path` is assigned a wildcard (`_`), the `walk` function will skip path creation entirely for faster evaluation.",
      "name": "output",
      "type": "array\u003carray[any], any\u003e"
    }
  },
  "yaml.is_valid": {
    "args": [
      {
        "description": "a YAML string",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Verifies the input string is a valid YAML document.",
    "result": {
      "description": "`true` if `x` is valid YAML, `false` otherwise",
      "name": "result",
      "type": "boolean"
    }
  },
  "yaml.marshal": {
    "args": [
      {
        "description": "the term to serialize",
        "name": "x",
        "type": "any"
      }
    ],
    "description": "Serializes the input term to YAML.",
    "result": {
      "description": "the YAML string representation of `x`",
      "name": "y",
      "type": "string"
    }
  },
  "yaml.unmarshal": {
    "args": [
      {
        "description": "a YAML string",
        "name": "x",
        "type": "string"
      }
    ],
    "description": "Deserializes the input string.",
    "result": {
      "description": "the term deserialized from `x`",
      "name": "y",
      "type": "any"
    }
  }
}

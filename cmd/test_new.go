package cmd

import (
	"context"
	"errors"
	"fmt"
	"io/fs"
	"os"

	"github.com/spf13/cobra"
	"github.com/spf13/viper"

	"github.com/open-policy-agent/opa/logging"

	"github.com/styrainc/enterprise-opa-private/pkg/test_bootstrap"
)

// Sub-command for automated test stub/mock generation.
func testNewCmd(config *viper.Viper, paths []string) *cobra.Command {
	var dataPaths, ignoreNames []string
	var entrypoint string
	var logger logging.Logger
	var err error

	cmd := &cobra.Command{
		Use: "new [flags] annotation",
		Example: `
Add additional generated tests to an 'eopa bootstrap'-generated test file,
selecting the new tests by their annotated name.

For example, given the annotated rule:

    # METADATA
	# custom:
	#   test-bootstrap-name: my-allow-rule
	allow if { ... }

We can add the rule to the test file using the command:

    eopa test new -d policy/ -e my/policy/allow 'my-allow-rule'

Note: If using a standard Styra DAS bundle structure, the policy entrypoint
should always be 'main/main':

    eopa test new -d das-policy/ -e main/main 'my-allow-rule'

Note: 'eopa test new' will look for .styra.yaml in the current
directory, the repository root, and your home directory. To use a different
config file location, pass --styra-config:

    eopa test new \
	  --styra-config ~/.styra-primary.yaml \
	  -d das-policy/ \
	  -e main/main \
	  'my-allow-rule'

Remember that for full test coverage, additional tests and test cases may
be required beyond those generated by this command!
`,
		Short: "Generate Rego test mocks automatically from Rego files or bundles",
		// Note(philip): In Cobra, the Args validation checks are run *before*
		// the PreRunE or RunE functions, so if we want a reliable error message
		// for the name collision case with `eopa test new`, then we have
		// to do the check here.
		Args: func(cmd *cobra.Command, args []string) error {
			// Pre-flight check to ensure we didn't have a name collision with `eopa test`!
			if _, err := os.Stat("new"); !errors.Is(err, fs.ErrNotExist) {
				return fmt.Errorf("Name collision between 'eopa test' and 'eopa test new' commands detected. No tests will be run or generated.")
			}

			if len(args) == 0 {
				return fmt.Errorf("need at least 1 entrypoint")
			}
			return nil
		},
		PreRunE: func(c *cobra.Command, _ []string) error {
			bindDASFlags(config, c)
			c.SilenceUsage = true

			lvl, _ := c.Flags().GetString(logLevel)
			format, _ := c.Flags().GetString("log-format")
			logger, err = getLogger(lvl, format, "")
			if err != nil {
				return err
			}

			path, _ := c.Flags().GetString(styraConfig)
			return readConfig(path, config, paths, logger)
		},
		RunE: func(c *cobra.Command, args []string) error {
			ctx, cancel := context.WithCancel(c.Context())
			defer cancel()

			// TODO(philip): Add DAS/Styra config auto-detection or includes here.

			annotation := args[0]
			forceOverwrite, _ := c.Flags().GetBool(force)

			return test_bootstrap.StartNew(ctx,
				test_bootstrap.Entrypoint(entrypoint),
				test_bootstrap.Annotation(annotation),
				test_bootstrap.Logger(logger),
				test_bootstrap.DataPaths(dataPaths),
				test_bootstrap.Ignores(ignoreNames),
				test_bootstrap.Force(forceOverwrite),
			)
		},
	}

	addDASFlags(cmd) // TODO(philip): Do we want "bindDASFlags" here?
	cmd.Flags().StringVarP(&entrypoint, "entrypoint", "e", "", "entrypoint rule or package to use for discovering the annotated test")
	cmd.Flags().StringSliceVarP(&ignoreNames, "ignore", "", []string{}, "set file and directory names to ignore during loading (e.g., '.*' excludes hidden files)")
	cmd.Flags().StringSliceVarP(&dataPaths, "data", "d", []string{}, "set policy or data file(s). Recursively traverses bundle folders. This flag can be repeated.")
	return cmd
}

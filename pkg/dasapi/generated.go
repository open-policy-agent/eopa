// Package dasapi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen/v2 version v2.0.0 DO NOT EDIT.
package dasapi

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
	strictnethttp "github.com/oapi-codegen/runtime/strictmiddleware/nethttp"
)

// CryptoFilterTree defines model for crypto.FilterTree.
type CryptoFilterTree struct {
	Digest *string                      `json:"digest,omitempty"`
	Nodes  *map[string]CryptoFilterTree `json:"nodes,omitempty"`
}

// CryptoSignature defines model for crypto.Signature.
type CryptoSignature struct {
	Excluded   *CryptoFilterTree            `json:"excluded,omitempty"`
	Signatures *[]CryptoSignatureSignatures `json:"signatures,omitempty"`
}

// CryptoSignatureSignatures defines model for crypto.Signature.signatures.
type CryptoSignatureSignatures map[string]string

// DataV1BuiltinMocks defines model for data.v1.BuiltinMocks.
type DataV1BuiltinMocks struct {
	DynamodbGet    *DataV1MocksDynamoDBGet    `json:"dynamodb.get,omitempty"`
	DynamodbQuery  *DataV1MocksDynamoDBQuery  `json:"dynamodb.query,omitempty"`
	HttpSend       *DataV1MocksHttpSend       `json:"http.send,omitempty"`
	MongodbFind    *DataV1MocksMongoDBFind    `json:"mongodb.find,omitempty"`
	MongodbFindOne *DataV1MocksMongoDBFindOne `json:"mongodb.find_one,omitempty"`
	OpaRuntime     *DataV1MocksOPARuntime     `json:"opa.runtime,omitempty"`
	SqlSend        *DataV1MocksSqlSend        `json:"sql.send,omitempty"`
}

// DataV1BuiltinMocksResponse defines model for data.v1.BuiltinMocksResponse.
type DataV1BuiltinMocksResponse struct {
	DynamodbGet    *DataV1MocksDynamoDBGetResponse    `json:"dynamodb.get,omitempty"`
	DynamodbQuery  *DataV1MocksDynamoDBQueryResponse  `json:"dynamodb.query,omitempty"`
	HttpSend       *DataV1MocksHttpSendResponse       `json:"http.send,omitempty"`
	MongodbFind    *DataV1MocksMongoDBFindResponse    `json:"mongodb.find,omitempty"`
	MongodbFindOne *DataV1MocksMongoDBFindOneResponse `json:"mongodb.find_one,omitempty"`
	SqlSend        *DataV1MocksSqlSendResponse        `json:"sql.send,omitempty"`
}

// DataV1DataPatchResponse defines model for data.v1.DataPatchResponse.
type DataV1DataPatchResponse struct {
	RequestId *string                       `json:"request_id,omitempty"`
	Result    DataV1DataPatchResponseResult `json:"result"`
}

// DataV1DataPatchResponseResult defines model for data.v1.DataPatchResponse.result.
type DataV1DataPatchResponseResult = interface{}

// DataV1DataPutResponse defines model for data.v1.DataPutResponse.
type DataV1DataPutResponse struct {
	RequestId *string `json:"request_id,omitempty"`
}

// DataV1DataRequest defines model for data.v1.DataRequest.
type DataV1DataRequest struct {
	// Data Initial data object
	Data  *map[string]interface{} `json:"data,omitempty"`
	Input *map[string]interface{} `json:"input,omitempty"`

	// Jsonpath Json Path expression to extract portions of documents
	Jsonpath *string             `json:"jsonpath,omitempty"`
	Mocks    *DataV1BuiltinMocks `json:"mocks,omitempty"`

	// NdBuiltinCache Cache containing results of non-deterministic built-in functions
	NdBuiltinCache *map[string]DataV1DataRequestNdBuiltinCache `json:"nd_builtin_cache,omitempty"`

	// QueryPackage The package name to be used with query in case of multiple rego modules
	QueryPackage *string `json:"query_package,omitempty"`

	// Rego Rego query to be executed for the documents
	Rego *string `json:"rego,omitempty"`

	// RegoModules List of rego modules to be loaded and executed for the documents
	RegoModules *map[string]string `json:"rego_modules,omitempty"`

	// Replay Inject STYRA_DAS_REPLAY environment variable into opa.runtime().env
	Replay *bool `json:"replay,omitempty"`

	// Sandbox Only used explicitly provided policies and data. Do not load anything from DAS
	Sandbox *bool `json:"sandbox,omitempty"`

	// Strict Enable strict Rego compilation mode
	Strict *bool `json:"strict,omitempty"`
}

// DataV1DataRequestNdBuiltinCache defines model for data.v1.DataRequest.nd_builtin_cache.
type DataV1DataRequestNdBuiltinCache = map[string]interface{}

// DataV1DataResponse defines model for data.v1.DataResponse.
type DataV1DataResponse struct {
	Mocks     *DataV1BuiltinMocksResponse `json:"mocks,omitempty"`
	RequestId *string                     `json:"request_id,omitempty"`
	Result    DataV1DataResponseResult    `json:"result"`
}

// DataV1DataResponseResult defines model for data.v1.DataResponse.result.
type DataV1DataResponseResult = interface{}

// DataV1MocksDynamoDBGet defines model for data.v1.MocksDynamoDBGet.
type DataV1MocksDynamoDBGet struct {
	// Data mock dynamodb.get data, the noop function is used if the list is empty
	Data []DataV1MocksDynamoDBGetData `json:"data"`
}

// DataV1MocksDynamoDBGetData defines model for data.v1.MocksDynamoDBGetData.
type DataV1MocksDynamoDBGetData struct {
	// Key the key to fetch from the table
	Key map[string]interface{} `json:"key"`

	// Region the AWS region to query
	Region string `json:"region"`

	// Result mock json result
	Result map[string]interface{} `json:"result"`

	// Table the Dynamo DB table to fetch from
	Table string `json:"table"`
}

// DataV1MocksDynamoDBGetResponse defines model for data.v1.MocksDynamoDBGetResponse.
type DataV1MocksDynamoDBGetResponse struct {
	// Mocked mock dynamodb.get response
	Mocked *[]DataV1MocksDynamoDBResponseForGet `json:"mocked,omitempty"`

	// Unmocked mock dynamodb.get response
	Unmocked *[]DataV1MocksDynamoDBResponseForGet `json:"unmocked,omitempty"`
}

// DataV1MocksDynamoDBQuery defines model for data.v1.MocksDynamoDBQuery.
type DataV1MocksDynamoDBQuery struct {
	// Data mock dynamodb.query data, the noop function is used if the list is empty
	Data []DataV1MocksDynamoDBQueryData `json:"data"`
}

// DataV1MocksDynamoDBQueryData defines model for data.v1.MocksDynamoDBQueryData.
type DataV1MocksDynamoDBQueryData struct {
	// KeyConditionExpression the key matching expression for the query
	KeyConditionExpression string `json:"key_condition_expression"`

	// Region the AWS region to query
	Region string `json:"region"`

	// Result mock json result
	Result map[string]interface{} `json:"result"`

	// Table the Dynamo DB table to fetch from
	Table string `json:"table"`
}

// DataV1MocksDynamoDBQueryResponse defines model for data.v1.MocksDynamoDBQueryResponse.
type DataV1MocksDynamoDBQueryResponse struct {
	// Mocked mock dynamodb.query response
	Mocked *[]DataV1MocksDynamoDBResponseForQuery `json:"mocked,omitempty"`

	// Unmocked mock dynamodb.query response
	Unmocked *[]DataV1MocksDynamoDBResponseForQuery `json:"unmocked,omitempty"`
}

// DataV1MocksDynamoDBResponseForGet defines model for data.v1.MocksDynamoDBResponseForGet.
type DataV1MocksDynamoDBResponseForGet struct {
	// Key the key to fetch from the table
	Key map[string]interface{} `json:"key"`

	// Region the AWS region to query
	Region string `json:"region"`

	// Table the Dynamo DB table to fetch from
	Table string `json:"table"`
}

// DataV1MocksDynamoDBResponseForQuery defines model for data.v1.MocksDynamoDBResponseForQuery.
type DataV1MocksDynamoDBResponseForQuery struct {
	// KeyConditionExpression the key matching expression for the query
	KeyConditionExpression string `json:"key_condition_expression"`

	// Region the AWS region to query
	Region string `json:"region"`

	// Table the Dynamo DB table to fetch from
	Table string `json:"table"`
}

// DataV1MocksHttpData defines model for data.v1.MocksHttpData.
type DataV1MocksHttpData struct {
	// Method request method
	Method string `json:"method"`

	// Result mock json result
	Result map[string]interface{} `json:"result"`

	// Url request URL
	Url string `json:"url"`
}

// DataV1MocksHttpResponse defines model for data.v1.MocksHttpResponse.
type DataV1MocksHttpResponse struct {
	// Method request method
	Method string `json:"method"`

	// Url request URL
	Url string `json:"url"`
}

// DataV1MocksHttpSend defines model for data.v1.MocksHttpSend.
type DataV1MocksHttpSend struct {
	// Data mock http.send data, the noop function is used if the list is empty
	Data []DataV1MocksHttpData `json:"data"`
}

// DataV1MocksHttpSendResponse defines model for data.v1.MocksHttpSendResponse.
type DataV1MocksHttpSendResponse struct {
	// Mocked mock http.send response
	Mocked *[]DataV1MocksHttpResponse `json:"mocked,omitempty"`

	// Unmocked mock http.send response
	Unmocked *[]DataV1MocksHttpResponse `json:"unmocked,omitempty"`
}

// DataV1MocksMongoDBFind defines model for data.v1.MocksMongoDBFind.
type DataV1MocksMongoDBFind struct {
	// Data mock mongodb.find data, the noop function is used if the list is empty
	Data []DataV1MocksMongoDBFindData `json:"data"`
}

// DataV1MocksMongoDBFindData defines model for data.v1.MocksMongoDBFindData.
type DataV1MocksMongoDBFindData struct {
	// Collection the collection to query
	Collection string `json:"collection"`

	// Database the name of the database
	Database string `json:"database"`

	// Filter the filter to use for the query
	Filter map[string]interface{} `json:"filter"`

	// Options the options to use for the query
	Options map[string]interface{} `json:"options"`

	// Result mock json result
	Result map[string]interface{} `json:"result"`

	// Uri the MongoDB URI
	Uri string `json:"uri"`
}

// DataV1MocksMongoDBFindOne defines model for data.v1.MocksMongoDBFindOne.
type DataV1MocksMongoDBFindOne struct {
	// Data mock mongodb.find_one data, the noop function is used if the list is empty
	Data []DataV1MocksMongoDBFindOneData `json:"data"`
}

// DataV1MocksMongoDBFindOneData defines model for data.v1.MocksMongoDBFindOneData.
type DataV1MocksMongoDBFindOneData struct {
	// Collection the collection to query
	Collection string `json:"collection"`

	// Database the name of the database
	Database string `json:"database"`

	// Filter the filter to use for the query
	Filter map[string]interface{} `json:"filter"`

	// Options the options to use for the query
	Options map[string]interface{} `json:"options"`

	// Result mock json result
	Result map[string]interface{} `json:"result"`

	// Uri the MongoDB URI
	Uri string `json:"uri"`
}

// DataV1MocksMongoDBFindOneResponse defines model for data.v1.MocksMongoDBFindOneResponse.
type DataV1MocksMongoDBFindOneResponse struct {
	// Mocked mock mongodb.find_one response
	Mocked *[]DataV1MocksMongoDBResponseForFindOne `json:"mocked,omitempty"`

	// Unmocked mock mongodb.find_one response
	Unmocked *[]DataV1MocksMongoDBResponseForFindOne `json:"unmocked,omitempty"`
}

// DataV1MocksMongoDBFindResponse defines model for data.v1.MocksMongoDBFindResponse.
type DataV1MocksMongoDBFindResponse struct {
	// Mocked mock mongodb.find response
	Mocked *[]DataV1MocksMongoDBResponseForFind `json:"mocked,omitempty"`

	// Unmocked mock mongodb.find response
	Unmocked *[]DataV1MocksMongoDBResponseForFind `json:"unmocked,omitempty"`
}

// DataV1MocksMongoDBResponseForFind defines model for data.v1.MocksMongoDBResponseForFind.
type DataV1MocksMongoDBResponseForFind struct {
	// Collection the collection to query
	Collection string `json:"collection"`

	// Database the name of the database
	Database string `json:"database"`

	// Filter the filter to use for the query
	Filter map[string]interface{} `json:"filter"`

	// Options the options to use for the query
	Options map[string]interface{} `json:"options"`

	// Uri the database URI
	Uri string `json:"uri"`
}

// DataV1MocksMongoDBResponseForFindOne defines model for data.v1.MocksMongoDBResponseForFindOne.
type DataV1MocksMongoDBResponseForFindOne struct {
	// Collection the collection to query
	Collection string `json:"collection"`

	// Database the name of the database
	Database string `json:"database"`

	// Filter the filter to use for the query
	Filter map[string]interface{} `json:"filter"`

	// Options the options to use for the query
	Options map[string]interface{} `json:"options"`

	// Uri the database URI
	Uri string `json:"uri"`
}

// DataV1MocksOPARuntime defines model for data.v1.MocksOPARuntime.
type DataV1MocksOPARuntime struct {
	// Result mock json result
	Result map[string]interface{} `json:"result"`
}

// DataV1MocksSqlData defines model for data.v1.MocksSqlData.
type DataV1MocksSqlData struct {
	// DataSourceName the database source
	DataSourceName string `json:"data_source_name"`

	// Driver SQL driver
	Driver string `json:"driver"`

	// Query the query run against the data source
	Query string `json:"query"`

	// Result mock json result
	Result map[string]interface{} `json:"result"`
}

// DataV1MocksSqlResponse defines model for data.v1.MocksSqlResponse.
type DataV1MocksSqlResponse struct {
	// DataSourceName the database source
	DataSourceName string `json:"data_source_name"`

	// Driver SQL driver
	Driver string `json:"driver"`

	// Query the query run against the data source
	Query string `json:"query"`
}

// DataV1MocksSqlSend defines model for data.v1.MocksSqlSend.
type DataV1MocksSqlSend struct {
	// Data mock sql.send data, the noop function is used if the list is empty
	Data []DataV1MocksSqlData `json:"data"`
}

// DataV1MocksSqlSendResponse defines model for data.v1.MocksSqlSendResponse.
type DataV1MocksSqlSendResponse struct {
	// Mocked mock sql.send response
	Mocked *[]DataV1MocksSqlResponse `json:"mocked,omitempty"`

	// Unmocked mock sql.send response
	Unmocked *[]DataV1MocksSqlResponse `json:"unmocked,omitempty"`
}

// GitV1Commit defines model for git.v1.Commit.
type GitV1Commit struct {
	Author string `json:"author"`
	Branch string `json:"branch"`
	Email  string `json:"email"`

	// Files Map of filenames to file contents
	Files map[string]string `json:"files"`

	// FilesToDelete List of filenames to delete from the repo
	FilesToDelete []string `json:"files_to_delete"`
	Message       string   `json:"message"`
}

// GitV1CommitInput defines model for git.v1.CommitInput.
type GitV1CommitInput struct {
	Author string `json:"author"`
	Email  string `json:"email"`

	// Files Map of filenames to file contents
	Files map[string]string `json:"files"`

	// FilesToDelete List of filenames to delete from the repo
	FilesToDelete []string `json:"files_to_delete"`
	Message       string   `json:"message"`
}

// GitV1DeleteBranchResponse defines model for git.v1.DeleteBranchResponse.
type GitV1DeleteBranchResponse struct {
	RequestId *string `json:"request_id,omitempty"`
}

// GitV1GetFilesResponse defines model for git.v1.GetFilesResponse.
type GitV1GetFilesResponse struct {
	RequestId *string        `json:"request_id,omitempty"`
	Result    GitV1RepoFiles `json:"result"`
}

// GitV1GitRepoConfig defines model for git.v1.GitRepoConfig.
type GitV1GitRepoConfig struct {
	// Commit Commit SHA. Only one of reference or commit can be set at any time
	Commit string `json:"commit"`

	// Credentials Credentials are looked under the key <name>/<creds>
	Credentials string `json:"credentials"`

	// Path Path to limit the import to
	Path string `json:"path"`

	// Reference Remote reference. Only one of reference or commit can be set at any time
	Reference      string               `json:"reference"`
	SshCredentials *GitV1SSHCredentials `json:"ssh_credentials,omitempty"`

	// Url Repository URL
	Url string `json:"url"`
}

// GitV1PostCommitResponse defines model for git.v1.PostCommitResponse.
type GitV1PostCommitResponse struct {
	RequestId *string     `json:"request_id,omitempty"`
	Result    GitV1Commit `json:"result"`
}

// GitV1RepoFiles defines model for git.v1.RepoFiles.
type GitV1RepoFiles struct {
	DeletedFiles *[]string         `json:"deleted_files,omitempty"`
	Files        map[string]string `json:"files"`
}

// GitV1SSHCredentials defines model for git.v1.SSHCredentials.
type GitV1SSHCredentials struct {
	// Passphrase Passphrase is looked under the key passphrase/<pass>
	Passphrase string `json:"passphrase"`

	// PrivateKey PrivateKey is looked under the key private-key/<key>
	PrivateKey string `json:"private_key"`
}

// GitV1VerifiedRepoConfig defines model for git.v1.VerifiedRepoConfig.
type GitV1VerifiedRepoConfig struct {
	// Commit Commit SHA. Only one of reference or commit can be set at any time
	Commit string `json:"commit"`

	// Credentials Credentials are looked under the key <name>/<creds>
	Credentials string `json:"credentials"`

	// Path Path to limit the import to
	Path string `json:"path"`

	// Reference Remote reference. Only one of reference or commit can be set at any time
	Reference string `json:"reference"`

	// Sha git SHA fetched from the repository if the provided config is correct. It can either be the HEAD of the configured reference or in the case of specifying a SHA in the config, the returned value will be the configured commit
	Sha            string               `json:"sha"`
	SshCredentials *GitV1SSHCredentials `json:"ssh_credentials,omitempty"`

	// Url Repository URL
	Url string `json:"url"`
}

// GitV1VerifyConfigRequest defines model for git.v1.VerifyConfigRequest.
type GitV1VerifyConfigRequest struct {
	// Commit Commit SHA. Only one of reference or commit can be set at any time
	Commit string `json:"commit"`

	// Credentials Credentials are looked under the key <name>/<creds>
	Credentials string `json:"credentials"`

	// Id id of the entity so that the config can be checked for duplicates
	Id string `json:"id"`

	// Path Path to limit the import to
	Path string `json:"path"`

	// Reference Remote reference. Only one of reference or commit can be set at any time
	Reference      string               `json:"reference"`
	SshCredentials *GitV1SSHCredentials `json:"ssh_credentials,omitempty"`

	// Url Repository URL
	Url string `json:"url"`
}

// GitV1VerifyConfigResponse defines model for git.v1.VerifyConfigResponse.
type GitV1VerifyConfigResponse struct {
	RequestId *string                 `json:"request_id,omitempty"`
	Result    GitV1VerifiedRepoConfig `json:"result"`
}

// LibrariesV1CreateLibraryRequest defines model for libraries.v1.CreateLibraryRequest.
type LibrariesV1CreateLibraryRequest struct {
	Description   string                          `json:"description"`
	ReadOnly      bool                            `json:"read_only"`
	SourceControl *LibrariesV1SourceControlConfig `json:"source_control,omitempty"`
}

// LibrariesV1LibrariesListResponse defines model for libraries.v1.LibrariesListResponse.
type LibrariesV1LibrariesListResponse struct {
	RequestId *string                    `json:"request_id,omitempty"`
	Result    []LibrariesV1LibraryEntity `json:"result"`
}

// LibrariesV1LibraryEntity defines model for libraries.v1.LibraryEntity.
type LibrariesV1LibraryEntity struct {
	Description   string                          `json:"description"`
	Id            string                          `json:"id"`
	Metadata      *MetaV2ObjectMeta               `json:"metadata,omitempty"`
	ReadOnly      bool                            `json:"read_only"`
	SourceControl *LibrariesV1SourceControlConfig `json:"source_control,omitempty"`
}

// LibrariesV1LibraryEntityExpanded defines model for libraries.v1.LibraryEntityExpanded.
type LibrariesV1LibraryEntityExpanded struct {
	Datasources   []SystemsV1DatasourceConfig     `json:"datasources"`
	Description   string                          `json:"description"`
	Id            string                          `json:"id"`
	Metadata      *MetaV2ObjectMeta               `json:"metadata,omitempty"`
	Policies      []SystemsV1PolicyConfig         `json:"policies"`
	ReadOnly      bool                            `json:"read_only"`
	SourceControl *LibrariesV1SourceControlConfig `json:"source_control,omitempty"`
}

// LibrariesV1LibraryResponse defines model for libraries.v1.LibraryResponse.
type LibrariesV1LibraryResponse struct {
	Result LibrariesV1LibraryEntityExpanded `json:"result"`
}

// LibrariesV1SourceControlConfig defines model for libraries.v1.SourceControlConfig.
type LibrariesV1SourceControlConfig struct {
	LibraryOrigin        *GitV1GitRepoConfig `json:"library_origin,omitempty"`
	Origin               *GitV1GitRepoConfig `json:"origin,omitempty"`
	UseWorkspaceSettings bool                `json:"use_workspace_settings"`
}

// MetaV1ErrorResponse defines model for meta.v1.ErrorResponse.
type MetaV1ErrorResponse struct {
	Code      string    `json:"code"`
	Errors    *[]string `json:"errors,omitempty"`
	Message   string    `json:"message"`
	RequestId *string   `json:"request_id,omitempty"`
}

// MetaV1ObjectMeta defines model for meta.v1.ObjectMeta.
type MetaV1ObjectMeta struct {
	CreatedAt           *time.Time `json:"created_at,omitempty"`
	CreatedBy           *string    `json:"created_by,omitempty"`
	CreatedThrough      *string    `json:"created_through,omitempty"`
	LastModifiedAt      *time.Time `json:"last_modified_at,omitempty"`
	LastModifiedBy      *string    `json:"last_modified_by,omitempty"`
	LastModifiedThrough *string    `json:"last_modified_through,omitempty"`
}

// MetaV1RequestObject defines model for meta.v1.RequestObject.
type MetaV1RequestObject = map[string]interface{}

// MetaV1Status defines model for meta.v1.Status.
type MetaV1Status struct {
	Code      string    `json:"code"`
	Message   string    `json:"message"`
	Timestamp time.Time `json:"timestamp"`
}

// MetaV2ObjectMeta defines model for meta.v2.ObjectMeta.
type MetaV2ObjectMeta struct {
	CreatedAt           *time.Time `json:"created_at,omitempty"`
	CreatedBy           *string    `json:"created_by,omitempty"`
	CreatedThrough      *string    `json:"created_through,omitempty"`
	LastModifiedAt      *time.Time `json:"last_modified_at,omitempty"`
	LastModifiedBy      *string    `json:"last_modified_by,omitempty"`
	LastModifiedThrough *string    `json:"last_modified_through,omitempty"`
}

// PoliciesV1PoliciesBulkUploadResponse defines model for policies.v1.PoliciesBulkUploadResponse.
type PoliciesV1PoliciesBulkUploadResponse struct {
	RequestId *string `json:"request_id,omitempty"`
}

// PoliciesV1PoliciesListResponse defines model for policies.v1.PoliciesListResponse.
type PoliciesV1PoliciesListResponse struct {
	Metadata  *[]MetaV1ObjectMeta                  `json:"metadata,omitempty"`
	RequestId *string                              `json:"request_id,omitempty"`
	Result    PoliciesV1PoliciesListResponseResult `json:"result"`
}

// PoliciesV1PoliciesListResponseResult defines model for policies.v1.PoliciesListResponse.result.
type PoliciesV1PoliciesListResponseResult = interface{}

// PoliciesV1PoliciesPutRequest defines model for policies.v1.PoliciesPutRequest.
type PoliciesV1PoliciesPutRequest struct {
	// Modules module file name to rego (and also data.json/data.yaml if enabled for the tenant) contents dictionary
	Modules   map[string]string `json:"modules"`
	Signature *CryptoSignature  `json:"signature,omitempty"`
}

// PoliciesV1PolicyDeleteResponse defines model for policies.v1.PolicyDeleteResponse.
type PoliciesV1PolicyDeleteResponse struct {
	RequestId *string `json:"request_id,omitempty"`
}

// PoliciesV1PolicyGetResponse defines model for policies.v1.PolicyGetResponse.
type PoliciesV1PolicyGetResponse struct {
	RequestId *string                           `json:"request_id,omitempty"`
	Result    PoliciesV1PolicyGetResponseResult `json:"result"`
}

// PoliciesV1PolicyGetResponseResult defines model for policies.v1.PolicyGetResponse.result.
type PoliciesV1PolicyGetResponseResult = interface{}

// PoliciesV1PolicyPutResponse defines model for policies.v1.PolicyPutResponse.
type PoliciesV1PolicyPutResponse struct {
	RequestId *string `json:"request_id,omitempty"`
}

// PoliciesV1RuleCounts defines model for policies.v1.RuleCounts.
type PoliciesV1RuleCounts struct {
	// Allow number of allow rules
	Allow int32 `json:"allow"`

	// Deny number of deny rules
	Deny int32 `json:"deny"`

	// Enforce number of enforce rules
	Enforce int32 `json:"enforce"`

	// Ignore number of ignore rules
	Ignore int32 `json:"ignore"`

	// Monitor number of monitor rules
	Monitor int32 `json:"monitor"`

	// Notify number of notify rules
	Notify int32 `json:"notify"`

	// Other number of unclassified rules
	Other int32 `json:"other"`

	// Test number of test rules
	Test int32 `json:"test"`

	// Total total number of rules
	Total int32 `json:"total"`
}

// SystemsV1DatasourceConfig defines model for systems.v1.DatasourceConfig.
type SystemsV1DatasourceConfig struct {
	// Category datasource category
	Category string `json:"category"`

	// Id datasource ID
	Id string `json:"id"`

	// Optional optional datasources can be deleted without being recreated automatically
	Optional *bool         `json:"optional,omitempty"`
	Status   *MetaV1Status `json:"status,omitempty"`
}

// SystemsV1EnforcementConfig defines model for systems.v1.EnforcementConfig.
type SystemsV1EnforcementConfig struct {
	// Enforced true if the policy is enforced
	Enforced bool `json:"enforced"`

	// Type enforcement type e.g. opa, test, mask
	Type string `json:"type"`
}

// SystemsV1Module defines model for systems.v1.Module.
type SystemsV1Module struct {
	// Name module name
	Name string `json:"name"`

	// Placeholder module is a placeholder
	Placeholder *bool `json:"placeholder,omitempty"`

	// ReadOnly true if module is read-only
	ReadOnly bool                  `json:"read_only"`
	Rules    *PoliciesV1RuleCounts `json:"rules,omitempty"`
}

// SystemsV1PolicyConfig defines model for systems.v1.PolicyConfig.
type SystemsV1PolicyConfig struct {
	// Created policy on when to (re)generate the policy
	Created     *string                    `json:"created,omitempty"`
	Enforcement SystemsV1EnforcementConfig `json:"enforcement"`

	// Id policy ID (path)
	Id string `json:"id"`

	// Modules rego modules policy consists of
	Modules *[]SystemsV1Module    `json:"modules,omitempty"`
	Rules   *PoliciesV1RuleCounts `json:"rules,omitempty"`

	// Type policy type e.g. validating/rules
	Type string `json:"type"`
}

// ListDataParams defines parameters for ListData.
type ListDataParams struct {
	// Rego Rego query to be executed for the documents
	Rego *string `form:"rego,omitempty" json:"rego,omitempty"`

	// Jsonpath Json Path expression to extract portions of documents
	Jsonpath *string `form:"jsonpath,omitempty" json:"jsonpath,omitempty"`

	// Sandbox Only used explicitly provided policies and data. Do not load anything from DAS
	Sandbox *bool `form:"sandbox,omitempty" json:"sandbox,omitempty"`

	// Strict Enable strict Rego compilation mode
	Strict *bool `form:"strict,omitempty" json:"strict,omitempty"`

	// Data Initial data object in JSON format
	Data *string `form:"data,omitempty" json:"data,omitempty"`

	// Download Download data as data.json file
	Download *bool `form:"download,omitempty" json:"download,omitempty"`

	// Limit Returns '413 Payload Too Large' response if the body size is greater than given limit.
	// The units KB, MB and etc can be used.
	// Example: 10 MB; 28 kilobytes; 2000
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`

	// IfNoneMatch The server will return the requested resource, with a 200 status, only if it doesn't have an ETag matching the given ones. See <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match> documentation.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// HeadListDataParams defines parameters for HeadListData.
type HeadListDataParams struct {
	// Rego Rego query to be executed for the documents
	Rego *string `form:"rego,omitempty" json:"rego,omitempty"`

	// Jsonpath Json Path expression to extract portions of documents
	Jsonpath *string `form:"jsonpath,omitempty" json:"jsonpath,omitempty"`

	// IfNoneMatch The server will return the requested resource, with a 200 status, only if it doesn't have an ETag matching the given ones. See <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match> documentation.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// ShowAllDataParams defines parameters for ShowAllData.
type ShowAllDataParams struct {
	// IfNoneMatch The server will return the requested resource, with a 200 status, only if it doesn't have an ETag matching the given ones. See <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match> documentation.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// GetDataParams defines parameters for GetData.
type GetDataParams struct {
	// Rego Rego query to be executed for the documents
	Rego *string `form:"rego,omitempty" json:"rego,omitempty"`

	// Jsonpath JSONPath expression to extract portions of documents
	Jsonpath *string `form:"jsonpath,omitempty" json:"jsonpath,omitempty"`

	// Sandbox Only used explicitly provided policies and data. Do not load anything from DAS
	Sandbox *bool `form:"sandbox,omitempty" json:"sandbox,omitempty"`

	// Strict Enable strict Rego compilation mode
	Strict *bool `form:"strict,omitempty" json:"strict,omitempty"`

	// Data Initial data object in JSON format
	Data *string `form:"data,omitempty" json:"data,omitempty"`

	// Download Download data as <name>.json file
	Download *bool `form:"download,omitempty" json:"download,omitempty"`

	// Limit Returns '413 Payload Too Large' response if the body size is greater than given limit.
	// The units KB, MB and etc can be used.
	// Example: 10 MB; 28 kilobytes; 2000
	Limit *string `form:"limit,omitempty" json:"limit,omitempty"`

	// IfNoneMatch The server will return the requested resource, with a 200 status, only if it doesn't have an ETag matching the given ones. See <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match> documentation.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// HeadGetDataParams defines parameters for HeadGetData.
type HeadGetDataParams struct {
	// Rego Rego query to be executed for the documents
	Rego *string `form:"rego,omitempty" json:"rego,omitempty"`

	// Jsonpath Json Path expression to extract portions of documents
	Jsonpath *string `form:"jsonpath,omitempty" json:"jsonpath,omitempty"`

	// IfNoneMatch The server will return the requested resource, with a 200 status, only if it doesn't have an ETag matching the given ones. See <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match> documentation.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// PatchDataParams defines parameters for PatchData.
type PatchDataParams struct {
	// IfMatch etag
	IfMatch *string `json:"If-Match,omitempty"`
}

// ShowDataParams defines parameters for ShowData.
type ShowDataParams struct {
	// IfNoneMatch The server will return the requested resource, with a 200 status, only if it doesn't have an ETag matching the given ones. See <https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/If-None-Match> documentation.
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// PutDataParams defines parameters for PutData.
type PutDataParams struct {
	// IfMatch etag
	IfMatch *string `json:"If-Match,omitempty"`
}

// ListPoliciesParams defines parameters for ListPolicies.
type ListPoliciesParams struct {
	// Metadata return rego metadata of specified type or all if no type provided
	Metadata *string `form:"metadata,omitempty" json:"metadata,omitempty"`

	// Modules return rego metadata for each module separately
	Modules *bool `form:"modules,omitempty" json:"modules,omitempty"`

	// Drafts return rego metadata for draft policies (when metadata flag is used)
	Drafts *bool `form:"drafts,omitempty" json:"drafts,omitempty"`

	// Prefix return only the policies having the prefix
	Prefix *string `form:"prefix,omitempty" json:"prefix,omitempty"`
}

// ListPlaygroundPoliciesParams defines parameters for ListPlaygroundPolicies.
type ListPlaygroundPoliciesParams struct {
	// Metadata return rego metadata of specified type or all if no type provided
	Metadata *string `form:"metadata,omitempty" json:"metadata,omitempty"`

	// Drafts return rego metadata for draft policies (when metadata flag is used)
	Drafts *bool `form:"drafts,omitempty" json:"drafts,omitempty"`
}

// ListSystemPoliciesParams defines parameters for ListSystemPolicies.
type ListSystemPoliciesParams struct {
	// Metadata return rego metadata of specified type or all if no type provided
	Metadata *string `form:"metadata,omitempty" json:"metadata,omitempty"`

	// Drafts return rego metadata for draft policies (when metadata flag is used)
	Drafts *bool `form:"drafts,omitempty" json:"drafts,omitempty"`
}

// GetPolicyParams defines parameters for GetPolicy.
type GetPolicyParams struct {
	// Dependencies include dependencies
	Dependencies *bool `form:"dependencies,omitempty" json:"dependencies,omitempty"`
}

// UpdatePolicyParams defines parameters for UpdatePolicy.
type UpdatePolicyParams struct {
	// IfNoneMatch etag
	IfNoneMatch *string `json:"If-None-Match,omitempty"`
}

// ShowAllDataJSONRequestBody defines body for ShowAllData for application/json ContentType.
type ShowAllDataJSONRequestBody = DataV1DataRequest

// ShowAllDataTextRequestBody defines body for ShowAllData for text/plain ContentType.
type ShowAllDataTextRequestBody = DataV1DataRequest

// PatchDataApplicationJSONPatchPlusJSONRequestBody defines body for PatchData for application/json-patch+json ContentType.
type PatchDataApplicationJSONPatchPlusJSONRequestBody = MetaV1RequestObject

// PatchDataApplicationVndStyraPatchPlusJSONRequestBody defines body for PatchData for application/vnd.styra.patch+json ContentType.
type PatchDataApplicationVndStyraPatchPlusJSONRequestBody = MetaV1RequestObject

// ShowDataJSONRequestBody defines body for ShowData for application/json ContentType.
type ShowDataJSONRequestBody = DataV1DataRequest

// ShowDataTextRequestBody defines body for ShowData for text/plain ContentType.
type ShowDataTextRequestBody = DataV1DataRequest

// PutDataJSONRequestBody defines body for PutData for application/json ContentType.
type PutDataJSONRequestBody = MetaV1RequestObject

// PutDataApplicationVndStyraPushPlusJSONRequestBody defines body for PutData for application/vnd.styra.push+json ContentType.
type PutDataApplicationVndStyraPushPlusJSONRequestBody = MetaV1RequestObject

// SourceControlVerifyConfigLibraryJSONRequestBody defines body for SourceControlVerifyConfigLibrary for application/json ContentType.
type SourceControlVerifyConfigLibraryJSONRequestBody = GitV1VerifyConfigRequest

// LibrariesUpdateJSONRequestBody defines body for LibrariesUpdate for application/json ContentType.
type LibrariesUpdateJSONRequestBody = LibrariesV1CreateLibraryRequest

// CommitFilesToSourceControlLibraryJSONRequestBody defines body for CommitFilesToSourceControlLibrary for application/json ContentType.
type CommitFilesToSourceControlLibraryJSONRequestBody = GitV1CommitInput

// UpdatePolicyJSONRequestBody defines body for UpdatePolicy for application/json ContentType.
type UpdatePolicyJSONRequestBody = PoliciesV1PoliciesPutRequest

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListData request
	ListData(ctx context.Context, params *ListDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadListData request
	HeadListData(ctx context.Context, params *HeadListDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowAllDataWithBody request with any body
	ShowAllDataWithBody(ctx context.Context, params *ShowAllDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ShowAllData(ctx context.Context, params *ShowAllDataParams, body ShowAllDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetData request
	GetData(ctx context.Context, name string, params *GetDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HeadGetData request
	HeadGetData(ctx context.Context, name string, params *HeadGetDataParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PatchDataWithBody request with any body
	PatchDataWithBody(ctx context.Context, name string, params *PatchDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchDataWithApplicationJSONPatchPlusJSONBody(ctx context.Context, name string, params *PatchDataParams, body PatchDataApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PatchDataWithApplicationVndStyraPatchPlusJSONBody(ctx context.Context, name string, params *PatchDataParams, body PatchDataApplicationVndStyraPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ShowDataWithBody request with any body
	ShowDataWithBody(ctx context.Context, name string, params *ShowDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ShowData(ctx context.Context, name string, params *ShowDataParams, body ShowDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutDataWithBody request with any body
	PutDataWithBody(ctx context.Context, name string, params *PutDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutData(ctx context.Context, name string, params *PutDataParams, body PutDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutDataWithApplicationVndStyraPushPlusJSONBody(ctx context.Context, name string, params *PutDataParams, body PutDataApplicationVndStyraPushPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LibrariesList request
	LibrariesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SourceControlVerifyConfigLibraryWithBody request with any body
	SourceControlVerifyConfigLibraryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SourceControlVerifyConfigLibrary(ctx context.Context, body SourceControlVerifyConfigLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LibrariesDelete request
	LibrariesDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LibrariesGet request
	LibrariesGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LibrariesUpdateWithBody request with any body
	LibrariesUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	LibrariesUpdate(ctx context.Context, id string, body LibrariesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserBranchLibrary request
	DeleteUserBranchLibrary(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSourceControlFilesBranchLibrary request
	GetSourceControlFilesBranchLibrary(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitFilesToSourceControlLibraryWithBody request with any body
	CommitFilesToSourceControlLibraryWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommitFilesToSourceControlLibrary(ctx context.Context, id string, body CommitFilesToSourceControlLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSourceControlFilesMasterLibrary request
	GetSourceControlFilesMasterLibrary(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPolicies request
	ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUploadPoliciesWithBody request with any body
	BulkUploadPoliciesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListPlaygroundPolicies request
	ListPlaygroundPolicies(ctx context.Context, params *ListPlaygroundPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUploadPlaygroundPoliciesWithBody request with any body
	BulkUploadPlaygroundPoliciesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListSystemPolicies request
	ListSystemPolicies(ctx context.Context, system string, params *ListSystemPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BulkUploadSystemPoliciesWithBody request with any body
	BulkUploadSystemPoliciesWithBody(ctx context.Context, system string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePolicy request
	DeletePolicy(ctx context.Context, policy string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPolicy request
	GetPolicy(ctx context.Context, policy string, params *GetPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdatePolicyWithBody request with any body
	UpdatePolicyWithBody(ctx context.Context, policy string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdatePolicy(ctx context.Context, policy string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListData(ctx context.Context, params *ListDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadListData(ctx context.Context, params *HeadListDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadListDataRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowAllDataWithBody(ctx context.Context, params *ShowAllDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowAllDataRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowAllData(ctx context.Context, params *ShowAllDataParams, body ShowAllDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowAllDataRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetData(ctx context.Context, name string, params *GetDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDataRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HeadGetData(ctx context.Context, name string, params *HeadGetDataParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHeadGetDataRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchDataWithBody(ctx context.Context, name string, params *PatchDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchDataRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchDataWithApplicationJSONPatchPlusJSONBody(ctx context.Context, name string, params *PatchDataParams, body PatchDataApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchDataRequestWithApplicationJSONPatchPlusJSONBody(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PatchDataWithApplicationVndStyraPatchPlusJSONBody(ctx context.Context, name string, params *PatchDataParams, body PatchDataApplicationVndStyraPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPatchDataRequestWithApplicationVndStyraPatchPlusJSONBody(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowDataWithBody(ctx context.Context, name string, params *ShowDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowDataRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ShowData(ctx context.Context, name string, params *ShowDataParams, body ShowDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewShowDataRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutDataWithBody(ctx context.Context, name string, params *PutDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutDataRequestWithBody(c.Server, name, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutData(ctx context.Context, name string, params *PutDataParams, body PutDataJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutDataRequest(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutDataWithApplicationVndStyraPushPlusJSONBody(ctx context.Context, name string, params *PutDataParams, body PutDataApplicationVndStyraPushPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutDataRequestWithApplicationVndStyraPushPlusJSONBody(c.Server, name, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LibrariesList(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLibrariesListRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SourceControlVerifyConfigLibraryWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSourceControlVerifyConfigLibraryRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SourceControlVerifyConfigLibrary(ctx context.Context, body SourceControlVerifyConfigLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSourceControlVerifyConfigLibraryRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LibrariesDelete(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLibrariesDeleteRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LibrariesGet(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLibrariesGetRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LibrariesUpdateWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLibrariesUpdateRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LibrariesUpdate(ctx context.Context, id string, body LibrariesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLibrariesUpdateRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserBranchLibrary(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserBranchLibraryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSourceControlFilesBranchLibrary(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSourceControlFilesBranchLibraryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitFilesToSourceControlLibraryWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitFilesToSourceControlLibraryRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitFilesToSourceControlLibrary(ctx context.Context, id string, body CommitFilesToSourceControlLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitFilesToSourceControlLibraryRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSourceControlFilesMasterLibrary(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSourceControlFilesMasterLibraryRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPolicies(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUploadPoliciesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUploadPoliciesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListPlaygroundPolicies(ctx context.Context, params *ListPlaygroundPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListPlaygroundPoliciesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUploadPlaygroundPoliciesWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUploadPlaygroundPoliciesRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListSystemPolicies(ctx context.Context, system string, params *ListSystemPoliciesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListSystemPoliciesRequest(c.Server, system, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BulkUploadSystemPoliciesWithBody(ctx context.Context, system string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBulkUploadSystemPoliciesRequestWithBody(c.Server, system, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePolicy(ctx context.Context, policy string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePolicyRequest(c.Server, policy)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPolicy(ctx context.Context, policy string, params *GetPolicyParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPolicyRequest(c.Server, policy, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicyWithBody(ctx context.Context, policy string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequestWithBody(c.Server, policy, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdatePolicy(ctx context.Context, policy string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdatePolicyRequest(c.Server, policy, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListDataRequest generates requests for ListData
func NewListDataRequest(server string, params *ListDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Rego != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rego", runtime.ParamLocationQuery, *params.Rego); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Jsonpath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsonpath", runtime.ParamLocationQuery, *params.Jsonpath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sandbox != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sandbox", runtime.ParamLocationQuery, *params.Sandbox); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Strict != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "strict", runtime.ParamLocationQuery, *params.Strict); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Data != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data", runtime.ParamLocationQuery, *params.Data); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Download != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "download", runtime.ParamLocationQuery, *params.Download); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfNoneMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-None-Match", headerParam0)
		}

	}

	return req, nil
}

// NewHeadListDataRequest generates requests for HeadListData
func NewHeadListDataRequest(server string, params *HeadListDataParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Rego != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rego", runtime.ParamLocationQuery, *params.Rego); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Jsonpath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsonpath", runtime.ParamLocationQuery, *params.Jsonpath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfNoneMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-None-Match", headerParam0)
		}

	}

	return req, nil
}

// NewShowAllDataRequest calls the generic ShowAllData builder with application/json body
func NewShowAllDataRequest(server string, params *ShowAllDataParams, body ShowAllDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewShowAllDataRequestWithBody(server, params, "application/json", bodyReader)
}

// NewShowAllDataRequestWithBody generates requests for ShowAllData with any type of body
func NewShowAllDataRequestWithBody(server string, params *ShowAllDataParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfNoneMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-None-Match", headerParam0)
		}

	}

	return req, nil
}

// NewGetDataRequest generates requests for GetData
func NewGetDataRequest(server string, name string, params *GetDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Rego != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rego", runtime.ParamLocationQuery, *params.Rego); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Jsonpath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsonpath", runtime.ParamLocationQuery, *params.Jsonpath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Sandbox != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sandbox", runtime.ParamLocationQuery, *params.Sandbox); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Strict != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "strict", runtime.ParamLocationQuery, *params.Strict); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Data != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "data", runtime.ParamLocationQuery, *params.Data); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Download != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "download", runtime.ParamLocationQuery, *params.Download); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfNoneMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-None-Match", headerParam0)
		}

	}

	return req, nil
}

// NewHeadGetDataRequest generates requests for HeadGetData
func NewHeadGetDataRequest(server string, name string, params *HeadGetDataParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Rego != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "rego", runtime.ParamLocationQuery, *params.Rego); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Jsonpath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jsonpath", runtime.ParamLocationQuery, *params.Jsonpath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("HEAD", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	if params != nil {

		if params.IfNoneMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-None-Match", headerParam0)
		}

	}

	return req, nil
}

// NewPatchDataRequestWithApplicationJSONPatchPlusJSONBody calls the generic PatchData builder with application/json-patch+json body
func NewPatchDataRequestWithApplicationJSONPatchPlusJSONBody(server string, name string, params *PatchDataParams, body PatchDataApplicationJSONPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchDataRequestWithBody(server, name, params, "application/json-patch+json", bodyReader)
}

// NewPatchDataRequestWithApplicationVndStyraPatchPlusJSONBody calls the generic PatchData builder with application/vnd.styra.patch+json body
func NewPatchDataRequestWithApplicationVndStyraPatchPlusJSONBody(server string, name string, params *PatchDataParams, body PatchDataApplicationVndStyraPatchPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPatchDataRequestWithBody(server, name, params, "application/vnd.styra.patch+json", bodyReader)
}

// NewPatchDataRequestWithBody generates requests for PatchData with any type of body
func NewPatchDataRequestWithBody(server string, name string, params *PatchDataParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewShowDataRequest calls the generic ShowData builder with application/json body
func NewShowDataRequest(server string, name string, params *ShowDataParams, body ShowDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewShowDataRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewShowDataRequestWithBody generates requests for ShowData with any type of body
func NewShowDataRequestWithBody(server string, name string, params *ShowDataParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfNoneMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-None-Match", headerParam0)
		}

	}

	return req, nil
}

// NewPutDataRequest calls the generic PutData builder with application/json body
func NewPutDataRequest(server string, name string, params *PutDataParams, body PutDataJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutDataRequestWithBody(server, name, params, "application/json", bodyReader)
}

// NewPutDataRequestWithApplicationVndStyraPushPlusJSONBody calls the generic PutData builder with application/vnd.styra.push+json body
func NewPutDataRequestWithApplicationVndStyraPushPlusJSONBody(server string, name string, params *PutDataParams, body PutDataApplicationVndStyraPushPlusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutDataRequestWithBody(server, name, params, "application/vnd.styra.push+json", bodyReader)
}

// NewPutDataRequestWithBody generates requests for PutData with any type of body
func NewPutDataRequestWithBody(server string, name string, params *PutDataParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/data/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, *params.IfMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-Match", headerParam0)
		}

	}

	return req, nil
}

// NewLibrariesListRequest generates requests for LibrariesList
func NewLibrariesListRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/libraries")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSourceControlVerifyConfigLibraryRequest calls the generic SourceControlVerifyConfigLibrary builder with application/json body
func NewSourceControlVerifyConfigLibraryRequest(server string, body SourceControlVerifyConfigLibraryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSourceControlVerifyConfigLibraryRequestWithBody(server, "application/json", bodyReader)
}

// NewSourceControlVerifyConfigLibraryRequestWithBody generates requests for SourceControlVerifyConfigLibrary with any type of body
func NewSourceControlVerifyConfigLibraryRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/libraries/source-control/verify-config")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewLibrariesDeleteRequest generates requests for LibrariesDelete
func NewLibrariesDeleteRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/libraries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLibrariesGetRequest generates requests for LibrariesGet
func NewLibrariesGetRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/libraries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLibrariesUpdateRequest calls the generic LibrariesUpdate builder with application/json body
func NewLibrariesUpdateRequest(server string, id string, body LibrariesUpdateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewLibrariesUpdateRequestWithBody(server, id, "application/json", bodyReader)
}

// NewLibrariesUpdateRequestWithBody generates requests for LibrariesUpdate with any type of body
func NewLibrariesUpdateRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/libraries/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteUserBranchLibraryRequest generates requests for DeleteUserBranchLibrary
func NewDeleteUserBranchLibraryRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/libraries/%s/branch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSourceControlFilesBranchLibraryRequest generates requests for GetSourceControlFilesBranchLibrary
func NewGetSourceControlFilesBranchLibraryRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/libraries/%s/branch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommitFilesToSourceControlLibraryRequest calls the generic CommitFilesToSourceControlLibrary builder with application/json body
func NewCommitFilesToSourceControlLibraryRequest(server string, id string, body CommitFilesToSourceControlLibraryJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommitFilesToSourceControlLibraryRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCommitFilesToSourceControlLibraryRequestWithBody generates requests for CommitFilesToSourceControlLibrary with any type of body
func NewCommitFilesToSourceControlLibraryRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/libraries/%s/commits", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSourceControlFilesMasterLibraryRequest generates requests for GetSourceControlFilesMasterLibrary
func NewGetSourceControlFilesMasterLibraryRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/libraries/%s/master", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListPoliciesRequest generates requests for ListPolicies
func NewListPoliciesRequest(server string, params *ListPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Metadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Modules != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "modules", runtime.ParamLocationQuery, *params.Modules); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Drafts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "drafts", runtime.ParamLocationQuery, *params.Drafts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Prefix != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "prefix", runtime.ParamLocationQuery, *params.Prefix); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkUploadPoliciesRequestWithBody generates requests for BulkUploadPolicies with any type of body
func NewBulkUploadPoliciesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/policies")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListPlaygroundPoliciesRequest generates requests for ListPlaygroundPolicies
func NewListPlaygroundPoliciesRequest(server string, params *ListPlaygroundPoliciesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/policies/playground")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Metadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Drafts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "drafts", runtime.ParamLocationQuery, *params.Drafts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkUploadPlaygroundPoliciesRequestWithBody generates requests for BulkUploadPlaygroundPolicies with any type of body
func NewBulkUploadPlaygroundPoliciesRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/policies/playground")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListSystemPoliciesRequest generates requests for ListSystemPolicies
func NewListSystemPoliciesRequest(server string, system string, params *ListSystemPoliciesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "system", runtime.ParamLocationPath, system)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/policies/systems/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Metadata != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "metadata", runtime.ParamLocationQuery, *params.Metadata); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Drafts != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "drafts", runtime.ParamLocationQuery, *params.Drafts); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBulkUploadSystemPoliciesRequestWithBody generates requests for BulkUploadSystemPolicies with any type of body
func NewBulkUploadSystemPoliciesRequestWithBody(server string, system string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "system", runtime.ParamLocationPath, system)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/policies/systems/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePolicyRequest generates requests for DeletePolicy
func NewDeletePolicyRequest(server string, policy string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy", runtime.ParamLocationPath, policy)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPolicyRequest generates requests for GetPolicy
func NewGetPolicyRequest(server string, policy string, params *GetPolicyParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy", runtime.ParamLocationPath, policy)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Dependencies != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "dependencies", runtime.ParamLocationQuery, *params.Dependencies); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdatePolicyRequest calls the generic UpdatePolicy builder with application/json body
func NewUpdatePolicyRequest(server string, policy string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdatePolicyRequestWithBody(server, policy, params, "application/json", bodyReader)
}

// NewUpdatePolicyRequestWithBody generates requests for UpdatePolicy with any type of body
func NewUpdatePolicyRequestWithBody(server string, policy string, params *UpdatePolicyParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "policy", runtime.ParamLocationPath, policy)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/policies/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		if params.IfNoneMatch != nil {
			var headerParam0 string

			headerParam0, err = runtime.StyleParamWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, *params.IfNoneMatch)
			if err != nil {
				return nil, err
			}

			req.Header.Set("If-None-Match", headerParam0)
		}

	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListDataWithResponse request
	ListDataWithResponse(ctx context.Context, params *ListDataParams, reqEditors ...RequestEditorFn) (*ListDataResponse, error)

	// HeadListDataWithResponse request
	HeadListDataWithResponse(ctx context.Context, params *HeadListDataParams, reqEditors ...RequestEditorFn) (*HeadListDataResponse, error)

	// ShowAllDataWithBodyWithResponse request with any body
	ShowAllDataWithBodyWithResponse(ctx context.Context, params *ShowAllDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShowAllDataResponse, error)

	ShowAllDataWithResponse(ctx context.Context, params *ShowAllDataParams, body ShowAllDataJSONRequestBody, reqEditors ...RequestEditorFn) (*ShowAllDataResponse, error)

	// GetDataWithResponse request
	GetDataWithResponse(ctx context.Context, name string, params *GetDataParams, reqEditors ...RequestEditorFn) (*GetDataResponse, error)

	// HeadGetDataWithResponse request
	HeadGetDataWithResponse(ctx context.Context, name string, params *HeadGetDataParams, reqEditors ...RequestEditorFn) (*HeadGetDataResponse, error)

	// PatchDataWithBodyWithResponse request with any body
	PatchDataWithBodyWithResponse(ctx context.Context, name string, params *PatchDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchDataResponse, error)

	PatchDataWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, name string, params *PatchDataParams, body PatchDataApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchDataResponse, error)

	PatchDataWithApplicationVndStyraPatchPlusJSONBodyWithResponse(ctx context.Context, name string, params *PatchDataParams, body PatchDataApplicationVndStyraPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchDataResponse, error)

	// ShowDataWithBodyWithResponse request with any body
	ShowDataWithBodyWithResponse(ctx context.Context, name string, params *ShowDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShowDataResponse, error)

	ShowDataWithResponse(ctx context.Context, name string, params *ShowDataParams, body ShowDataJSONRequestBody, reqEditors ...RequestEditorFn) (*ShowDataResponse, error)

	// PutDataWithBodyWithResponse request with any body
	PutDataWithBodyWithResponse(ctx context.Context, name string, params *PutDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutDataResponse, error)

	PutDataWithResponse(ctx context.Context, name string, params *PutDataParams, body PutDataJSONRequestBody, reqEditors ...RequestEditorFn) (*PutDataResponse, error)

	PutDataWithApplicationVndStyraPushPlusJSONBodyWithResponse(ctx context.Context, name string, params *PutDataParams, body PutDataApplicationVndStyraPushPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutDataResponse, error)

	// LibrariesListWithResponse request
	LibrariesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LibrariesListResponse, error)

	// SourceControlVerifyConfigLibraryWithBodyWithResponse request with any body
	SourceControlVerifyConfigLibraryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SourceControlVerifyConfigLibraryResponse, error)

	SourceControlVerifyConfigLibraryWithResponse(ctx context.Context, body SourceControlVerifyConfigLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*SourceControlVerifyConfigLibraryResponse, error)

	// LibrariesDeleteWithResponse request
	LibrariesDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*LibrariesDeleteResponse, error)

	// LibrariesGetWithResponse request
	LibrariesGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*LibrariesGetResponse, error)

	// LibrariesUpdateWithBodyWithResponse request with any body
	LibrariesUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LibrariesUpdateResponse, error)

	LibrariesUpdateWithResponse(ctx context.Context, id string, body LibrariesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*LibrariesUpdateResponse, error)

	// DeleteUserBranchLibraryWithResponse request
	DeleteUserBranchLibraryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteUserBranchLibraryResponse, error)

	// GetSourceControlFilesBranchLibraryWithResponse request
	GetSourceControlFilesBranchLibraryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSourceControlFilesBranchLibraryResponse, error)

	// CommitFilesToSourceControlLibraryWithBodyWithResponse request with any body
	CommitFilesToSourceControlLibraryWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitFilesToSourceControlLibraryResponse, error)

	CommitFilesToSourceControlLibraryWithResponse(ctx context.Context, id string, body CommitFilesToSourceControlLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitFilesToSourceControlLibraryResponse, error)

	// GetSourceControlFilesMasterLibraryWithResponse request
	GetSourceControlFilesMasterLibraryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSourceControlFilesMasterLibraryResponse, error)

	// ListPoliciesWithResponse request
	ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error)

	// BulkUploadPoliciesWithBodyWithResponse request with any body
	BulkUploadPoliciesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUploadPoliciesResponse, error)

	// ListPlaygroundPoliciesWithResponse request
	ListPlaygroundPoliciesWithResponse(ctx context.Context, params *ListPlaygroundPoliciesParams, reqEditors ...RequestEditorFn) (*ListPlaygroundPoliciesResponse, error)

	// BulkUploadPlaygroundPoliciesWithBodyWithResponse request with any body
	BulkUploadPlaygroundPoliciesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUploadPlaygroundPoliciesResponse, error)

	// ListSystemPoliciesWithResponse request
	ListSystemPoliciesWithResponse(ctx context.Context, system string, params *ListSystemPoliciesParams, reqEditors ...RequestEditorFn) (*ListSystemPoliciesResponse, error)

	// BulkUploadSystemPoliciesWithBodyWithResponse request with any body
	BulkUploadSystemPoliciesWithBodyWithResponse(ctx context.Context, system string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUploadSystemPoliciesResponse, error)

	// DeletePolicyWithResponse request
	DeletePolicyWithResponse(ctx context.Context, policy string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error)

	// GetPolicyWithResponse request
	GetPolicyWithResponse(ctx context.Context, policy string, params *GetPolicyParams, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error)

	// UpdatePolicyWithBodyWithResponse request with any body
	UpdatePolicyWithBodyWithResponse(ctx context.Context, policy string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)

	UpdatePolicyWithResponse(ctx context.Context, policy string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error)
}

type ListDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataV1DataResponse
	JSON404      *MetaV1ErrorResponse
	JSON413      *MetaV1ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ListDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadListDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *MetaV1ErrorResponse
}

// Status returns HTTPResponse.Status
func (r HeadListDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadListDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowAllDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataV1DataResponse
	JSON404      *MetaV1ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ShowAllDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowAllDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataV1DataResponse
	JSON404      *MetaV1ErrorResponse
	JSON413      *MetaV1ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HeadGetDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *MetaV1ErrorResponse
}

// Status returns HTTPResponse.Status
func (r HeadGetDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HeadGetDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PatchDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataV1DataPatchResponse
	JSON404      *MetaV1ErrorResponse
	JSON413      *MetaV1ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PatchDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ShowDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataV1DataResponse
	JSON404      *MetaV1ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ShowDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ShowDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutDataResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *DataV1DataPutResponse
	JSON404      *MetaV1ErrorResponse
	JSON413      *MetaV1ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PutDataResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutDataResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LibrariesListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LibrariesV1LibrariesListResponse
}

// Status returns HTTPResponse.Status
func (r LibrariesListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LibrariesListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SourceControlVerifyConfigLibraryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitV1VerifyConfigResponse
	JSON400      *MetaV1ErrorResponse
}

// Status returns HTTPResponse.Status
func (r SourceControlVerifyConfigLibraryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SourceControlVerifyConfigLibraryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LibrariesDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r LibrariesDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LibrariesDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LibrariesGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LibrariesV1LibraryResponse
}

// Status returns HTTPResponse.Status
func (r LibrariesGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LibrariesGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LibrariesUpdateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LibrariesV1LibraryResponse
}

// Status returns HTTPResponse.Status
func (r LibrariesUpdateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LibrariesUpdateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserBranchLibraryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitV1DeleteBranchResponse
	JSON404      *MetaV1ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteUserBranchLibraryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserBranchLibraryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSourceControlFilesBranchLibraryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitV1GetFilesResponse
	JSON404      *MetaV1ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSourceControlFilesBranchLibraryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSourceControlFilesBranchLibraryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitFilesToSourceControlLibraryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitV1PostCommitResponse
	JSON404      *MetaV1ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CommitFilesToSourceControlLibraryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitFilesToSourceControlLibraryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSourceControlFilesMasterLibraryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GitV1GetFilesResponse
	JSON404      *MetaV1ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSourceControlFilesMasterLibraryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSourceControlFilesMasterLibraryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PoliciesV1PoliciesListResponse
}

// Status returns HTTPResponse.Status
func (r ListPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUploadPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PoliciesV1PoliciesBulkUploadResponse
}

// Status returns HTTPResponse.Status
func (r BulkUploadPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUploadPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListPlaygroundPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PoliciesV1PoliciesListResponse
}

// Status returns HTTPResponse.Status
func (r ListPlaygroundPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListPlaygroundPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUploadPlaygroundPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PoliciesV1PoliciesBulkUploadResponse
}

// Status returns HTTPResponse.Status
func (r BulkUploadPlaygroundPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUploadPlaygroundPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListSystemPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PoliciesV1PoliciesListResponse
}

// Status returns HTTPResponse.Status
func (r ListSystemPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListSystemPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BulkUploadSystemPoliciesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PoliciesV1PoliciesBulkUploadResponse
}

// Status returns HTTPResponse.Status
func (r BulkUploadSystemPoliciesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BulkUploadSystemPoliciesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PoliciesV1PolicyDeleteResponse
	JSON404      *MetaV1ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeletePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PoliciesV1PolicyGetResponse
	JSON404      *MetaV1ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetPolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdatePolicyResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *PoliciesV1PolicyPutResponse
}

// Status returns HTTPResponse.Status
func (r UpdatePolicyResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdatePolicyResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListDataWithResponse request returning *ListDataResponse
func (c *ClientWithResponses) ListDataWithResponse(ctx context.Context, params *ListDataParams, reqEditors ...RequestEditorFn) (*ListDataResponse, error) {
	rsp, err := c.ListData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListDataResponse(rsp)
}

// HeadListDataWithResponse request returning *HeadListDataResponse
func (c *ClientWithResponses) HeadListDataWithResponse(ctx context.Context, params *HeadListDataParams, reqEditors ...RequestEditorFn) (*HeadListDataResponse, error) {
	rsp, err := c.HeadListData(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadListDataResponse(rsp)
}

// ShowAllDataWithBodyWithResponse request with arbitrary body returning *ShowAllDataResponse
func (c *ClientWithResponses) ShowAllDataWithBodyWithResponse(ctx context.Context, params *ShowAllDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShowAllDataResponse, error) {
	rsp, err := c.ShowAllDataWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowAllDataResponse(rsp)
}

func (c *ClientWithResponses) ShowAllDataWithResponse(ctx context.Context, params *ShowAllDataParams, body ShowAllDataJSONRequestBody, reqEditors ...RequestEditorFn) (*ShowAllDataResponse, error) {
	rsp, err := c.ShowAllData(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowAllDataResponse(rsp)
}

// GetDataWithResponse request returning *GetDataResponse
func (c *ClientWithResponses) GetDataWithResponse(ctx context.Context, name string, params *GetDataParams, reqEditors ...RequestEditorFn) (*GetDataResponse, error) {
	rsp, err := c.GetData(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDataResponse(rsp)
}

// HeadGetDataWithResponse request returning *HeadGetDataResponse
func (c *ClientWithResponses) HeadGetDataWithResponse(ctx context.Context, name string, params *HeadGetDataParams, reqEditors ...RequestEditorFn) (*HeadGetDataResponse, error) {
	rsp, err := c.HeadGetData(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHeadGetDataResponse(rsp)
}

// PatchDataWithBodyWithResponse request with arbitrary body returning *PatchDataResponse
func (c *ClientWithResponses) PatchDataWithBodyWithResponse(ctx context.Context, name string, params *PatchDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PatchDataResponse, error) {
	rsp, err := c.PatchDataWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchDataResponse(rsp)
}

func (c *ClientWithResponses) PatchDataWithApplicationJSONPatchPlusJSONBodyWithResponse(ctx context.Context, name string, params *PatchDataParams, body PatchDataApplicationJSONPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchDataResponse, error) {
	rsp, err := c.PatchDataWithApplicationJSONPatchPlusJSONBody(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchDataResponse(rsp)
}

func (c *ClientWithResponses) PatchDataWithApplicationVndStyraPatchPlusJSONBodyWithResponse(ctx context.Context, name string, params *PatchDataParams, body PatchDataApplicationVndStyraPatchPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PatchDataResponse, error) {
	rsp, err := c.PatchDataWithApplicationVndStyraPatchPlusJSONBody(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePatchDataResponse(rsp)
}

// ShowDataWithBodyWithResponse request with arbitrary body returning *ShowDataResponse
func (c *ClientWithResponses) ShowDataWithBodyWithResponse(ctx context.Context, name string, params *ShowDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ShowDataResponse, error) {
	rsp, err := c.ShowDataWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowDataResponse(rsp)
}

func (c *ClientWithResponses) ShowDataWithResponse(ctx context.Context, name string, params *ShowDataParams, body ShowDataJSONRequestBody, reqEditors ...RequestEditorFn) (*ShowDataResponse, error) {
	rsp, err := c.ShowData(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseShowDataResponse(rsp)
}

// PutDataWithBodyWithResponse request with arbitrary body returning *PutDataResponse
func (c *ClientWithResponses) PutDataWithBodyWithResponse(ctx context.Context, name string, params *PutDataParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutDataResponse, error) {
	rsp, err := c.PutDataWithBody(ctx, name, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutDataResponse(rsp)
}

func (c *ClientWithResponses) PutDataWithResponse(ctx context.Context, name string, params *PutDataParams, body PutDataJSONRequestBody, reqEditors ...RequestEditorFn) (*PutDataResponse, error) {
	rsp, err := c.PutData(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutDataResponse(rsp)
}

func (c *ClientWithResponses) PutDataWithApplicationVndStyraPushPlusJSONBodyWithResponse(ctx context.Context, name string, params *PutDataParams, body PutDataApplicationVndStyraPushPlusJSONRequestBody, reqEditors ...RequestEditorFn) (*PutDataResponse, error) {
	rsp, err := c.PutDataWithApplicationVndStyraPushPlusJSONBody(ctx, name, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutDataResponse(rsp)
}

// LibrariesListWithResponse request returning *LibrariesListResponse
func (c *ClientWithResponses) LibrariesListWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*LibrariesListResponse, error) {
	rsp, err := c.LibrariesList(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLibrariesListResponse(rsp)
}

// SourceControlVerifyConfigLibraryWithBodyWithResponse request with arbitrary body returning *SourceControlVerifyConfigLibraryResponse
func (c *ClientWithResponses) SourceControlVerifyConfigLibraryWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SourceControlVerifyConfigLibraryResponse, error) {
	rsp, err := c.SourceControlVerifyConfigLibraryWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSourceControlVerifyConfigLibraryResponse(rsp)
}

func (c *ClientWithResponses) SourceControlVerifyConfigLibraryWithResponse(ctx context.Context, body SourceControlVerifyConfigLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*SourceControlVerifyConfigLibraryResponse, error) {
	rsp, err := c.SourceControlVerifyConfigLibrary(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSourceControlVerifyConfigLibraryResponse(rsp)
}

// LibrariesDeleteWithResponse request returning *LibrariesDeleteResponse
func (c *ClientWithResponses) LibrariesDeleteWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*LibrariesDeleteResponse, error) {
	rsp, err := c.LibrariesDelete(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLibrariesDeleteResponse(rsp)
}

// LibrariesGetWithResponse request returning *LibrariesGetResponse
func (c *ClientWithResponses) LibrariesGetWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*LibrariesGetResponse, error) {
	rsp, err := c.LibrariesGet(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLibrariesGetResponse(rsp)
}

// LibrariesUpdateWithBodyWithResponse request with arbitrary body returning *LibrariesUpdateResponse
func (c *ClientWithResponses) LibrariesUpdateWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*LibrariesUpdateResponse, error) {
	rsp, err := c.LibrariesUpdateWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLibrariesUpdateResponse(rsp)
}

func (c *ClientWithResponses) LibrariesUpdateWithResponse(ctx context.Context, id string, body LibrariesUpdateJSONRequestBody, reqEditors ...RequestEditorFn) (*LibrariesUpdateResponse, error) {
	rsp, err := c.LibrariesUpdate(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLibrariesUpdateResponse(rsp)
}

// DeleteUserBranchLibraryWithResponse request returning *DeleteUserBranchLibraryResponse
func (c *ClientWithResponses) DeleteUserBranchLibraryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteUserBranchLibraryResponse, error) {
	rsp, err := c.DeleteUserBranchLibrary(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserBranchLibraryResponse(rsp)
}

// GetSourceControlFilesBranchLibraryWithResponse request returning *GetSourceControlFilesBranchLibraryResponse
func (c *ClientWithResponses) GetSourceControlFilesBranchLibraryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSourceControlFilesBranchLibraryResponse, error) {
	rsp, err := c.GetSourceControlFilesBranchLibrary(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSourceControlFilesBranchLibraryResponse(rsp)
}

// CommitFilesToSourceControlLibraryWithBodyWithResponse request with arbitrary body returning *CommitFilesToSourceControlLibraryResponse
func (c *ClientWithResponses) CommitFilesToSourceControlLibraryWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitFilesToSourceControlLibraryResponse, error) {
	rsp, err := c.CommitFilesToSourceControlLibraryWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitFilesToSourceControlLibraryResponse(rsp)
}

func (c *ClientWithResponses) CommitFilesToSourceControlLibraryWithResponse(ctx context.Context, id string, body CommitFilesToSourceControlLibraryJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitFilesToSourceControlLibraryResponse, error) {
	rsp, err := c.CommitFilesToSourceControlLibrary(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitFilesToSourceControlLibraryResponse(rsp)
}

// GetSourceControlFilesMasterLibraryWithResponse request returning *GetSourceControlFilesMasterLibraryResponse
func (c *ClientWithResponses) GetSourceControlFilesMasterLibraryWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetSourceControlFilesMasterLibraryResponse, error) {
	rsp, err := c.GetSourceControlFilesMasterLibrary(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSourceControlFilesMasterLibraryResponse(rsp)
}

// ListPoliciesWithResponse request returning *ListPoliciesResponse
func (c *ClientWithResponses) ListPoliciesWithResponse(ctx context.Context, params *ListPoliciesParams, reqEditors ...RequestEditorFn) (*ListPoliciesResponse, error) {
	rsp, err := c.ListPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPoliciesResponse(rsp)
}

// BulkUploadPoliciesWithBodyWithResponse request with arbitrary body returning *BulkUploadPoliciesResponse
func (c *ClientWithResponses) BulkUploadPoliciesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUploadPoliciesResponse, error) {
	rsp, err := c.BulkUploadPoliciesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUploadPoliciesResponse(rsp)
}

// ListPlaygroundPoliciesWithResponse request returning *ListPlaygroundPoliciesResponse
func (c *ClientWithResponses) ListPlaygroundPoliciesWithResponse(ctx context.Context, params *ListPlaygroundPoliciesParams, reqEditors ...RequestEditorFn) (*ListPlaygroundPoliciesResponse, error) {
	rsp, err := c.ListPlaygroundPolicies(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListPlaygroundPoliciesResponse(rsp)
}

// BulkUploadPlaygroundPoliciesWithBodyWithResponse request with arbitrary body returning *BulkUploadPlaygroundPoliciesResponse
func (c *ClientWithResponses) BulkUploadPlaygroundPoliciesWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUploadPlaygroundPoliciesResponse, error) {
	rsp, err := c.BulkUploadPlaygroundPoliciesWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUploadPlaygroundPoliciesResponse(rsp)
}

// ListSystemPoliciesWithResponse request returning *ListSystemPoliciesResponse
func (c *ClientWithResponses) ListSystemPoliciesWithResponse(ctx context.Context, system string, params *ListSystemPoliciesParams, reqEditors ...RequestEditorFn) (*ListSystemPoliciesResponse, error) {
	rsp, err := c.ListSystemPolicies(ctx, system, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListSystemPoliciesResponse(rsp)
}

// BulkUploadSystemPoliciesWithBodyWithResponse request with arbitrary body returning *BulkUploadSystemPoliciesResponse
func (c *ClientWithResponses) BulkUploadSystemPoliciesWithBodyWithResponse(ctx context.Context, system string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BulkUploadSystemPoliciesResponse, error) {
	rsp, err := c.BulkUploadSystemPoliciesWithBody(ctx, system, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBulkUploadSystemPoliciesResponse(rsp)
}

// DeletePolicyWithResponse request returning *DeletePolicyResponse
func (c *ClientWithResponses) DeletePolicyWithResponse(ctx context.Context, policy string, reqEditors ...RequestEditorFn) (*DeletePolicyResponse, error) {
	rsp, err := c.DeletePolicy(ctx, policy, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePolicyResponse(rsp)
}

// GetPolicyWithResponse request returning *GetPolicyResponse
func (c *ClientWithResponses) GetPolicyWithResponse(ctx context.Context, policy string, params *GetPolicyParams, reqEditors ...RequestEditorFn) (*GetPolicyResponse, error) {
	rsp, err := c.GetPolicy(ctx, policy, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPolicyResponse(rsp)
}

// UpdatePolicyWithBodyWithResponse request with arbitrary body returning *UpdatePolicyResponse
func (c *ClientWithResponses) UpdatePolicyWithBodyWithResponse(ctx context.Context, policy string, params *UpdatePolicyParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicyWithBody(ctx, policy, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

func (c *ClientWithResponses) UpdatePolicyWithResponse(ctx context.Context, policy string, params *UpdatePolicyParams, body UpdatePolicyJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdatePolicyResponse, error) {
	rsp, err := c.UpdatePolicy(ctx, policy, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdatePolicyResponse(rsp)
}

// ParseListDataResponse parses an HTTP response from a ListDataWithResponse call
func ParseListDataResponse(rsp *http.Response) (*ListDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataV1DataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseHeadListDataResponse parses an HTTP response from a HeadListDataWithResponse call
func ParseHeadListDataResponse(rsp *http.Response) (*HeadListDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadListDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseShowAllDataResponse parses an HTTP response from a ShowAllDataWithResponse call
func ParseShowAllDataResponse(rsp *http.Response) (*ShowAllDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowAllDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataV1DataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetDataResponse parses an HTTP response from a GetDataWithResponse call
func ParseGetDataResponse(rsp *http.Response) (*GetDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataV1DataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseHeadGetDataResponse parses an HTTP response from a HeadGetDataWithResponse call
func ParseHeadGetDataResponse(rsp *http.Response) (*HeadGetDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HeadGetDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePatchDataResponse parses an HTTP response from a PatchDataWithResponse call
func ParsePatchDataResponse(rsp *http.Response) (*PatchDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PatchDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataV1DataPatchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseShowDataResponse parses an HTTP response from a ShowDataWithResponse call
func ParseShowDataResponse(rsp *http.Response) (*ShowDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ShowDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataV1DataResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutDataResponse parses an HTTP response from a PutDataWithResponse call
func ParsePutDataResponse(rsp *http.Response) (*PutDataResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutDataResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest DataV1DataPutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 413:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON413 = &dest

	}

	return response, nil
}

// ParseLibrariesListResponse parses an HTTP response from a LibrariesListWithResponse call
func ParseLibrariesListResponse(rsp *http.Response) (*LibrariesListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LibrariesListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LibrariesV1LibrariesListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSourceControlVerifyConfigLibraryResponse parses an HTTP response from a SourceControlVerifyConfigLibraryWithResponse call
func ParseSourceControlVerifyConfigLibraryResponse(rsp *http.Response) (*SourceControlVerifyConfigLibraryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SourceControlVerifyConfigLibraryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitV1VerifyConfigResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseLibrariesDeleteResponse parses an HTTP response from a LibrariesDeleteWithResponse call
func ParseLibrariesDeleteResponse(rsp *http.Response) (*LibrariesDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LibrariesDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseLibrariesGetResponse parses an HTTP response from a LibrariesGetWithResponse call
func ParseLibrariesGetResponse(rsp *http.Response) (*LibrariesGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LibrariesGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LibrariesV1LibraryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseLibrariesUpdateResponse parses an HTTP response from a LibrariesUpdateWithResponse call
func ParseLibrariesUpdateResponse(rsp *http.Response) (*LibrariesUpdateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LibrariesUpdateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LibrariesV1LibraryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteUserBranchLibraryResponse parses an HTTP response from a DeleteUserBranchLibraryWithResponse call
func ParseDeleteUserBranchLibraryResponse(rsp *http.Response) (*DeleteUserBranchLibraryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserBranchLibraryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitV1DeleteBranchResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSourceControlFilesBranchLibraryResponse parses an HTTP response from a GetSourceControlFilesBranchLibraryWithResponse call
func ParseGetSourceControlFilesBranchLibraryResponse(rsp *http.Response) (*GetSourceControlFilesBranchLibraryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSourceControlFilesBranchLibraryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitV1GetFilesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCommitFilesToSourceControlLibraryResponse parses an HTTP response from a CommitFilesToSourceControlLibraryWithResponse call
func ParseCommitFilesToSourceControlLibraryResponse(rsp *http.Response) (*CommitFilesToSourceControlLibraryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitFilesToSourceControlLibraryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitV1PostCommitResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSourceControlFilesMasterLibraryResponse parses an HTTP response from a GetSourceControlFilesMasterLibraryWithResponse call
func ParseGetSourceControlFilesMasterLibraryResponse(rsp *http.Response) (*GetSourceControlFilesMasterLibraryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSourceControlFilesMasterLibraryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GitV1GetFilesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListPoliciesResponse parses an HTTP response from a ListPoliciesWithResponse call
func ParseListPoliciesResponse(rsp *http.Response) (*ListPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PoliciesV1PoliciesListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBulkUploadPoliciesResponse parses an HTTP response from a BulkUploadPoliciesWithResponse call
func ParseBulkUploadPoliciesResponse(rsp *http.Response) (*BulkUploadPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUploadPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PoliciesV1PoliciesBulkUploadResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListPlaygroundPoliciesResponse parses an HTTP response from a ListPlaygroundPoliciesWithResponse call
func ParseListPlaygroundPoliciesResponse(rsp *http.Response) (*ListPlaygroundPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListPlaygroundPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PoliciesV1PoliciesListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBulkUploadPlaygroundPoliciesResponse parses an HTTP response from a BulkUploadPlaygroundPoliciesWithResponse call
func ParseBulkUploadPlaygroundPoliciesResponse(rsp *http.Response) (*BulkUploadPlaygroundPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUploadPlaygroundPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PoliciesV1PoliciesBulkUploadResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListSystemPoliciesResponse parses an HTTP response from a ListSystemPoliciesWithResponse call
func ParseListSystemPoliciesResponse(rsp *http.Response) (*ListSystemPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListSystemPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PoliciesV1PoliciesListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBulkUploadSystemPoliciesResponse parses an HTTP response from a BulkUploadSystemPoliciesWithResponse call
func ParseBulkUploadSystemPoliciesResponse(rsp *http.Response) (*BulkUploadSystemPoliciesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BulkUploadSystemPoliciesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PoliciesV1PoliciesBulkUploadResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeletePolicyResponse parses an HTTP response from a DeletePolicyWithResponse call
func ParseDeletePolicyResponse(rsp *http.Response) (*DeletePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PoliciesV1PolicyDeleteResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPolicyResponse parses an HTTP response from a GetPolicyWithResponse call
func ParseGetPolicyResponse(rsp *http.Response) (*GetPolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PoliciesV1PolicyGetResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest MetaV1ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdatePolicyResponse parses an HTTP response from a UpdatePolicyWithResponse call
func ParseUpdatePolicyResponse(rsp *http.Response) (*UpdatePolicyResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdatePolicyResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest PoliciesV1PolicyPutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// List data
	// (GET /v1/data)
	ListData(w http.ResponseWriter, r *http.Request, params ListDataParams)
	// Check size of data
	// (HEAD /v1/data)
	HeadListData(w http.ResponseWriter, r *http.Request, params HeadListDataParams)
	// Show all data
	// (POST /v1/data)
	ShowAllData(w http.ResponseWriter, r *http.Request, params ShowAllDataParams)
	// Get data
	// (GET /v1/data/{name})
	GetData(w http.ResponseWriter, r *http.Request, name string, params GetDataParams)
	// Check the size of the data
	// (HEAD /v1/data/{name})
	HeadGetData(w http.ResponseWriter, r *http.Request, name string, params HeadGetDataParams)
	// Patch data
	// (PATCH /v1/data/{name})
	PatchData(w http.ResponseWriter, r *http.Request, name string, params PatchDataParams)
	// Show data
	// (POST /v1/data/{name})
	ShowData(w http.ResponseWriter, r *http.Request, name string, params ShowDataParams)
	// Publish data
	// (PUT /v1/data/{name})
	PutData(w http.ResponseWriter, r *http.Request, name string, params PutDataParams)
	// List all libraries
	// (GET /v1/libraries)
	LibrariesList(w http.ResponseWriter, r *http.Request)
	// Verify git access
	// (POST /v1/libraries/source-control/verify-config)
	SourceControlVerifyConfigLibrary(w http.ResponseWriter, r *http.Request)
	// Delete a library
	// (DELETE /v1/libraries/{id})
	LibrariesDelete(w http.ResponseWriter, r *http.Request, id string)
	// Get a library
	// (GET /v1/libraries/{id})
	LibrariesGet(w http.ResponseWriter, r *http.Request, id string)
	// Upsert a new library
	// (PUT /v1/libraries/{id})
	LibrariesUpdate(w http.ResponseWriter, r *http.Request, id string)
	// Delete a user-owned branch
	// (DELETE /v1/libraries/{id}/branch)
	DeleteUserBranchLibrary(w http.ResponseWriter, r *http.Request, id string)
	// List files in Styra DAS-created branch.
	// (GET /v1/libraries/{id}/branch)
	GetSourceControlFilesBranchLibrary(w http.ResponseWriter, r *http.Request, id string)
	// Commit files to library source control
	// (POST /v1/libraries/{id}/commits)
	CommitFilesToSourceControlLibrary(w http.ResponseWriter, r *http.Request, id string)
	// List files in current branch.
	// (GET /v1/libraries/{id}/master)
	GetSourceControlFilesMasterLibrary(w http.ResponseWriter, r *http.Request, id string)
	// List policies
	// (GET /v1/policies)
	ListPolicies(w http.ResponseWriter, r *http.Request, params ListPoliciesParams)
	// Bulk upload policies
	// (POST /v1/policies)
	BulkUploadPolicies(w http.ResponseWriter, r *http.Request)
	// List playground policies
	// (GET /v1/policies/playground)
	ListPlaygroundPolicies(w http.ResponseWriter, r *http.Request, params ListPlaygroundPoliciesParams)
	// Bulk upload playground policies
	// (POST /v1/policies/playground)
	BulkUploadPlaygroundPolicies(w http.ResponseWriter, r *http.Request)
	// List system policies
	// (GET /v1/policies/systems/{system})
	ListSystemPolicies(w http.ResponseWriter, r *http.Request, system string, params ListSystemPoliciesParams)
	// Bulk upload system policies
	// (POST /v1/policies/systems/{system})
	BulkUploadSystemPolicies(w http.ResponseWriter, r *http.Request, system string)
	// Delete a policy
	// (DELETE /v1/policies/{policy})
	DeletePolicy(w http.ResponseWriter, r *http.Request, policy string)
	// Get a policy
	// (GET /v1/policies/{policy})
	GetPolicy(w http.ResponseWriter, r *http.Request, policy string, params GetPolicyParams)
	// Update a policy
	// (PUT /v1/policies/{policy})
	UpdatePolicy(w http.ResponseWriter, r *http.Request, policy string, params UpdatePolicyParams)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// List data
// (GET /v1/data)
func (_ Unimplemented) ListData(w http.ResponseWriter, r *http.Request, params ListDataParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Check size of data
// (HEAD /v1/data)
func (_ Unimplemented) HeadListData(w http.ResponseWriter, r *http.Request, params HeadListDataParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Show all data
// (POST /v1/data)
func (_ Unimplemented) ShowAllData(w http.ResponseWriter, r *http.Request, params ShowAllDataParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get data
// (GET /v1/data/{name})
func (_ Unimplemented) GetData(w http.ResponseWriter, r *http.Request, name string, params GetDataParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Check the size of the data
// (HEAD /v1/data/{name})
func (_ Unimplemented) HeadGetData(w http.ResponseWriter, r *http.Request, name string, params HeadGetDataParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Patch data
// (PATCH /v1/data/{name})
func (_ Unimplemented) PatchData(w http.ResponseWriter, r *http.Request, name string, params PatchDataParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Show data
// (POST /v1/data/{name})
func (_ Unimplemented) ShowData(w http.ResponseWriter, r *http.Request, name string, params ShowDataParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Publish data
// (PUT /v1/data/{name})
func (_ Unimplemented) PutData(w http.ResponseWriter, r *http.Request, name string, params PutDataParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List all libraries
// (GET /v1/libraries)
func (_ Unimplemented) LibrariesList(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Verify git access
// (POST /v1/libraries/source-control/verify-config)
func (_ Unimplemented) SourceControlVerifyConfigLibrary(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a library
// (DELETE /v1/libraries/{id})
func (_ Unimplemented) LibrariesDelete(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a library
// (GET /v1/libraries/{id})
func (_ Unimplemented) LibrariesGet(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Upsert a new library
// (PUT /v1/libraries/{id})
func (_ Unimplemented) LibrariesUpdate(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a user-owned branch
// (DELETE /v1/libraries/{id}/branch)
func (_ Unimplemented) DeleteUserBranchLibrary(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List files in Styra DAS-created branch.
// (GET /v1/libraries/{id}/branch)
func (_ Unimplemented) GetSourceControlFilesBranchLibrary(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Commit files to library source control
// (POST /v1/libraries/{id}/commits)
func (_ Unimplemented) CommitFilesToSourceControlLibrary(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List files in current branch.
// (GET /v1/libraries/{id}/master)
func (_ Unimplemented) GetSourceControlFilesMasterLibrary(w http.ResponseWriter, r *http.Request, id string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List policies
// (GET /v1/policies)
func (_ Unimplemented) ListPolicies(w http.ResponseWriter, r *http.Request, params ListPoliciesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Bulk upload policies
// (POST /v1/policies)
func (_ Unimplemented) BulkUploadPolicies(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List playground policies
// (GET /v1/policies/playground)
func (_ Unimplemented) ListPlaygroundPolicies(w http.ResponseWriter, r *http.Request, params ListPlaygroundPoliciesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Bulk upload playground policies
// (POST /v1/policies/playground)
func (_ Unimplemented) BulkUploadPlaygroundPolicies(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List system policies
// (GET /v1/policies/systems/{system})
func (_ Unimplemented) ListSystemPolicies(w http.ResponseWriter, r *http.Request, system string, params ListSystemPoliciesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Bulk upload system policies
// (POST /v1/policies/systems/{system})
func (_ Unimplemented) BulkUploadSystemPolicies(w http.ResponseWriter, r *http.Request, system string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a policy
// (DELETE /v1/policies/{policy})
func (_ Unimplemented) DeletePolicy(w http.ResponseWriter, r *http.Request, policy string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get a policy
// (GET /v1/policies/{policy})
func (_ Unimplemented) GetPolicy(w http.ResponseWriter, r *http.Request, policy string, params GetPolicyParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Update a policy
// (PUT /v1/policies/{policy})
func (_ Unimplemented) UpdatePolicy(w http.ResponseWriter, r *http.Request, policy string, params UpdatePolicyParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// ListData operation middleware
func (siw *ServerInterfaceWrapper) ListData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListDataParams

	// ------------- Optional query parameter "rego" -------------

	err = runtime.BindQueryParameter("form", true, false, "rego", r.URL.Query(), &params.Rego)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "rego", Err: err})
		return
	}

	// ------------- Optional query parameter "jsonpath" -------------

	err = runtime.BindQueryParameter("form", true, false, "jsonpath", r.URL.Query(), &params.Jsonpath)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jsonpath", Err: err})
		return
	}

	// ------------- Optional query parameter "sandbox" -------------

	err = runtime.BindQueryParameter("form", true, false, "sandbox", r.URL.Query(), &params.Sandbox)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sandbox", Err: err})
		return
	}

	// ------------- Optional query parameter "strict" -------------

	err = runtime.BindQueryParameter("form", true, false, "strict", r.URL.Query(), &params.Strict)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "strict", Err: err})
		return
	}

	// ------------- Optional query parameter "data" -------------

	err = runtime.BindQueryParameter("form", true, false, "data", r.URL.Query(), &params.Data)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "data", Err: err})
		return
	}

	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", r.URL.Query(), &params.Download)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "download", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, valueList[0], &IfNoneMatch)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListData(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// HeadListData operation middleware
func (siw *ServerInterfaceWrapper) HeadListData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadListDataParams

	// ------------- Optional query parameter "rego" -------------

	err = runtime.BindQueryParameter("form", true, false, "rego", r.URL.Query(), &params.Rego)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "rego", Err: err})
		return
	}

	// ------------- Optional query parameter "jsonpath" -------------

	err = runtime.BindQueryParameter("form", true, false, "jsonpath", r.URL.Query(), &params.Jsonpath)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jsonpath", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, valueList[0], &IfNoneMatch)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadListData(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ShowAllData operation middleware
func (siw *ServerInterfaceWrapper) ShowAllData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ShowAllDataParams

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, valueList[0], &IfNoneMatch)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowAllData(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetData operation middleware
func (siw *ServerInterfaceWrapper) GetData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, chi.URLParam(r, "name"), &name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetDataParams

	// ------------- Optional query parameter "rego" -------------

	err = runtime.BindQueryParameter("form", true, false, "rego", r.URL.Query(), &params.Rego)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "rego", Err: err})
		return
	}

	// ------------- Optional query parameter "jsonpath" -------------

	err = runtime.BindQueryParameter("form", true, false, "jsonpath", r.URL.Query(), &params.Jsonpath)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jsonpath", Err: err})
		return
	}

	// ------------- Optional query parameter "sandbox" -------------

	err = runtime.BindQueryParameter("form", true, false, "sandbox", r.URL.Query(), &params.Sandbox)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "sandbox", Err: err})
		return
	}

	// ------------- Optional query parameter "strict" -------------

	err = runtime.BindQueryParameter("form", true, false, "strict", r.URL.Query(), &params.Strict)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "strict", Err: err})
		return
	}

	// ------------- Optional query parameter "data" -------------

	err = runtime.BindQueryParameter("form", true, false, "data", r.URL.Query(), &params.Data)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "data", Err: err})
		return
	}

	// ------------- Optional query parameter "download" -------------

	err = runtime.BindQueryParameter("form", true, false, "download", r.URL.Query(), &params.Download)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "download", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, valueList[0], &IfNoneMatch)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetData(w, r, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// HeadGetData operation middleware
func (siw *ServerInterfaceWrapper) HeadGetData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, chi.URLParam(r, "name"), &name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params HeadGetDataParams

	// ------------- Optional query parameter "rego" -------------

	err = runtime.BindQueryParameter("form", true, false, "rego", r.URL.Query(), &params.Rego)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "rego", Err: err})
		return
	}

	// ------------- Optional query parameter "jsonpath" -------------

	err = runtime.BindQueryParameter("form", true, false, "jsonpath", r.URL.Query(), &params.Jsonpath)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "jsonpath", Err: err})
		return
	}

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, valueList[0], &IfNoneMatch)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.HeadGetData(w, r, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PatchData operation middleware
func (siw *ServerInterfaceWrapper) PatchData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, chi.URLParam(r, "name"), &name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PatchDataParams

	headers := r.Header

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PatchData(w, r, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ShowData operation middleware
func (siw *ServerInterfaceWrapper) ShowData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, chi.URLParam(r, "name"), &name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ShowDataParams

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, valueList[0], &IfNoneMatch)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ShowData(w, r, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// PutData operation middleware
func (siw *ServerInterfaceWrapper) PutData(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "name" -------------
	var name string

	err = runtime.BindStyledParameterWithLocation("simple", false, "name", runtime.ParamLocationPath, chi.URLParam(r, "name"), &name)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "name", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params PutDataParams

	headers := r.Header

	// ------------- Optional header parameter "If-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-Match")]; found {
		var IfMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-Match", runtime.ParamLocationHeader, valueList[0], &IfMatch)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-Match", Err: err})
			return
		}

		params.IfMatch = &IfMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.PutData(w, r, name, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// LibrariesList operation middleware
func (siw *ServerInterfaceWrapper) LibrariesList(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LibrariesList(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// SourceControlVerifyConfigLibrary operation middleware
func (siw *ServerInterfaceWrapper) SourceControlVerifyConfigLibrary(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SourceControlVerifyConfigLibrary(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// LibrariesDelete operation middleware
func (siw *ServerInterfaceWrapper) LibrariesDelete(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LibrariesDelete(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// LibrariesGet operation middleware
func (siw *ServerInterfaceWrapper) LibrariesGet(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LibrariesGet(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// LibrariesUpdate operation middleware
func (siw *ServerInterfaceWrapper) LibrariesUpdate(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LibrariesUpdate(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeleteUserBranchLibrary operation middleware
func (siw *ServerInterfaceWrapper) DeleteUserBranchLibrary(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteUserBranchLibrary(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSourceControlFilesBranchLibrary operation middleware
func (siw *ServerInterfaceWrapper) GetSourceControlFilesBranchLibrary(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSourceControlFilesBranchLibrary(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// CommitFilesToSourceControlLibrary operation middleware
func (siw *ServerInterfaceWrapper) CommitFilesToSourceControlLibrary(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CommitFilesToSourceControlLibrary(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetSourceControlFilesMasterLibrary operation middleware
func (siw *ServerInterfaceWrapper) GetSourceControlFilesMasterLibrary(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, chi.URLParam(r, "id"), &id)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetSourceControlFilesMasterLibrary(w, r, id)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPoliciesParams

	// ------------- Optional query parameter "metadata" -------------

	err = runtime.BindQueryParameter("form", true, false, "metadata", r.URL.Query(), &params.Metadata)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "metadata", Err: err})
		return
	}

	// ------------- Optional query parameter "modules" -------------

	err = runtime.BindQueryParameter("form", true, false, "modules", r.URL.Query(), &params.Modules)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "modules", Err: err})
		return
	}

	// ------------- Optional query parameter "drafts" -------------

	err = runtime.BindQueryParameter("form", true, false, "drafts", r.URL.Query(), &params.Drafts)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "drafts", Err: err})
		return
	}

	// ------------- Optional query parameter "prefix" -------------

	err = runtime.BindQueryParameter("form", true, false, "prefix", r.URL.Query(), &params.Prefix)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "prefix", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPolicies(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// BulkUploadPolicies operation middleware
func (siw *ServerInterfaceWrapper) BulkUploadPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BulkUploadPolicies(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListPlaygroundPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListPlaygroundPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListPlaygroundPoliciesParams

	// ------------- Optional query parameter "metadata" -------------

	err = runtime.BindQueryParameter("form", true, false, "metadata", r.URL.Query(), &params.Metadata)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "metadata", Err: err})
		return
	}

	// ------------- Optional query parameter "drafts" -------------

	err = runtime.BindQueryParameter("form", true, false, "drafts", r.URL.Query(), &params.Drafts)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "drafts", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListPlaygroundPolicies(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// BulkUploadPlaygroundPolicies operation middleware
func (siw *ServerInterfaceWrapper) BulkUploadPlaygroundPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BulkUploadPlaygroundPolicies(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// ListSystemPolicies operation middleware
func (siw *ServerInterfaceWrapper) ListSystemPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "system" -------------
	var system string

	err = runtime.BindStyledParameterWithLocation("simple", false, "system", runtime.ParamLocationPath, chi.URLParam(r, "system"), &system)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "system", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListSystemPoliciesParams

	// ------------- Optional query parameter "metadata" -------------

	err = runtime.BindQueryParameter("form", true, false, "metadata", r.URL.Query(), &params.Metadata)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "metadata", Err: err})
		return
	}

	// ------------- Optional query parameter "drafts" -------------

	err = runtime.BindQueryParameter("form", true, false, "drafts", r.URL.Query(), &params.Drafts)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "drafts", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListSystemPolicies(w, r, system, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// BulkUploadSystemPolicies operation middleware
func (siw *ServerInterfaceWrapper) BulkUploadSystemPolicies(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "system" -------------
	var system string

	err = runtime.BindStyledParameterWithLocation("simple", false, "system", runtime.ParamLocationPath, chi.URLParam(r, "system"), &system)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "system", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.BulkUploadSystemPolicies(w, r, system)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// DeletePolicy operation middleware
func (siw *ServerInterfaceWrapper) DeletePolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "policy" -------------
	var policy string

	err = runtime.BindStyledParameterWithLocation("simple", false, "policy", runtime.ParamLocationPath, chi.URLParam(r, "policy"), &policy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "policy", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeletePolicy(w, r, policy)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// GetPolicy operation middleware
func (siw *ServerInterfaceWrapper) GetPolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "policy" -------------
	var policy string

	err = runtime.BindStyledParameterWithLocation("simple", false, "policy", runtime.ParamLocationPath, chi.URLParam(r, "policy"), &policy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "policy", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetPolicyParams

	// ------------- Optional query parameter "dependencies" -------------

	err = runtime.BindQueryParameter("form", true, false, "dependencies", r.URL.Query(), &params.Dependencies)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "dependencies", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetPolicy(w, r, policy, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

// UpdatePolicy operation middleware
func (siw *ServerInterfaceWrapper) UpdatePolicy(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// ------------- Path parameter "policy" -------------
	var policy string

	err = runtime.BindStyledParameterWithLocation("simple", false, "policy", runtime.ParamLocationPath, chi.URLParam(r, "policy"), &policy)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "policy", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params UpdatePolicyParams

	headers := r.Header

	// ------------- Optional header parameter "If-None-Match" -------------
	if valueList, found := headers[http.CanonicalHeaderKey("If-None-Match")]; found {
		var IfNoneMatch string
		n := len(valueList)
		if n != 1 {
			siw.ErrorHandlerFunc(w, r, &TooManyValuesForParamError{ParamName: "If-None-Match", Count: n})
			return
		}

		err = runtime.BindStyledParameterWithLocation("simple", false, "If-None-Match", runtime.ParamLocationHeader, valueList[0], &IfNoneMatch)
		if err != nil {
			siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "If-None-Match", Err: err})
			return
		}

		params.IfNoneMatch = &IfNoneMatch

	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdatePolicy(w, r, policy, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r.WithContext(ctx))
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/data", wrapper.ListData)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/v1/data", wrapper.HeadListData)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/data", wrapper.ShowAllData)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/data/{name}", wrapper.GetData)
	})
	r.Group(func(r chi.Router) {
		r.Head(options.BaseURL+"/v1/data/{name}", wrapper.HeadGetData)
	})
	r.Group(func(r chi.Router) {
		r.Patch(options.BaseURL+"/v1/data/{name}", wrapper.PatchData)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/data/{name}", wrapper.ShowData)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v1/data/{name}", wrapper.PutData)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/libraries", wrapper.LibrariesList)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/libraries/source-control/verify-config", wrapper.SourceControlVerifyConfigLibrary)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v1/libraries/{id}", wrapper.LibrariesDelete)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/libraries/{id}", wrapper.LibrariesGet)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v1/libraries/{id}", wrapper.LibrariesUpdate)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v1/libraries/{id}/branch", wrapper.DeleteUserBranchLibrary)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/libraries/{id}/branch", wrapper.GetSourceControlFilesBranchLibrary)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/libraries/{id}/commits", wrapper.CommitFilesToSourceControlLibrary)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/libraries/{id}/master", wrapper.GetSourceControlFilesMasterLibrary)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/policies", wrapper.ListPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/policies", wrapper.BulkUploadPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/policies/playground", wrapper.ListPlaygroundPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/policies/playground", wrapper.BulkUploadPlaygroundPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/policies/systems/{system}", wrapper.ListSystemPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/v1/policies/systems/{system}", wrapper.BulkUploadSystemPolicies)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/v1/policies/{policy}", wrapper.DeletePolicy)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/v1/policies/{policy}", wrapper.GetPolicy)
	})
	r.Group(func(r chi.Router) {
		r.Put(options.BaseURL+"/v1/policies/{policy}", wrapper.UpdatePolicy)
	})

	return r
}

type ListDataRequestObject struct {
	Params ListDataParams
}

type ListDataResponseObject interface {
	VisitListDataResponse(w http.ResponseWriter) error
}

type ListData200ResponseHeaders struct {
	Etag string
}

type ListData200JSONResponse struct {
	Body    DataV1DataResponse
	Headers ListData200ResponseHeaders
}

func (response ListData200JSONResponse) VisitListDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type ListData304Response struct {
}

func (response ListData304Response) VisitListDataResponse(w http.ResponseWriter) error {
	w.WriteHeader(304)
	return nil
}

type ListData404JSONResponse MetaV1ErrorResponse

func (response ListData404JSONResponse) VisitListDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListData413JSONResponse MetaV1ErrorResponse

func (response ListData413JSONResponse) VisitListDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response)
}

type HeadListDataRequestObject struct {
	Params HeadListDataParams
}

type HeadListDataResponseObject interface {
	VisitHeadListDataResponse(w http.ResponseWriter) error
}

type HeadListData200ResponseHeaders struct {
	Etag string
}

type HeadListData200Response struct {
	Headers HeadListData200ResponseHeaders
}

func (response HeadListData200Response) VisitHeadListDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.WriteHeader(200)
	return nil
}

type HeadListData304Response struct {
}

func (response HeadListData304Response) VisitHeadListDataResponse(w http.ResponseWriter) error {
	w.WriteHeader(304)
	return nil
}

type HeadListData404JSONResponse MetaV1ErrorResponse

func (response HeadListData404JSONResponse) VisitHeadListDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ShowAllDataRequestObject struct {
	Params   ShowAllDataParams
	JSONBody *ShowAllDataJSONRequestBody
	TextBody *ShowAllDataTextRequestBody
}

type ShowAllDataResponseObject interface {
	VisitShowAllDataResponse(w http.ResponseWriter) error
}

type ShowAllData200ResponseHeaders struct {
	Etag string
}

type ShowAllData200JSONResponse struct {
	Body    DataV1DataResponse
	Headers ShowAllData200ResponseHeaders
}

func (response ShowAllData200JSONResponse) VisitShowAllDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type ShowAllData304Response struct {
}

func (response ShowAllData304Response) VisitShowAllDataResponse(w http.ResponseWriter) error {
	w.WriteHeader(304)
	return nil
}

type ShowAllData404JSONResponse MetaV1ErrorResponse

func (response ShowAllData404JSONResponse) VisitShowAllDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetDataRequestObject struct {
	Name   string `json:"name"`
	Params GetDataParams
}

type GetDataResponseObject interface {
	VisitGetDataResponse(w http.ResponseWriter) error
}

type GetData200ResponseHeaders struct {
	Etag string
}

type GetData200JSONResponse struct {
	Body    DataV1DataResponse
	Headers GetData200ResponseHeaders
}

func (response GetData200JSONResponse) VisitGetDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type GetData304Response struct {
}

func (response GetData304Response) VisitGetDataResponse(w http.ResponseWriter) error {
	w.WriteHeader(304)
	return nil
}

type GetData404JSONResponse MetaV1ErrorResponse

func (response GetData404JSONResponse) VisitGetDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetData413JSONResponse MetaV1ErrorResponse

func (response GetData413JSONResponse) VisitGetDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response)
}

type HeadGetDataRequestObject struct {
	Name   string `json:"name"`
	Params HeadGetDataParams
}

type HeadGetDataResponseObject interface {
	VisitHeadGetDataResponse(w http.ResponseWriter) error
}

type HeadGetData200ResponseHeaders struct {
	Etag string
}

type HeadGetData200Response struct {
	Headers HeadGetData200ResponseHeaders
}

func (response HeadGetData200Response) VisitHeadGetDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.WriteHeader(200)
	return nil
}

type HeadGetData304Response struct {
}

func (response HeadGetData304Response) VisitHeadGetDataResponse(w http.ResponseWriter) error {
	w.WriteHeader(304)
	return nil
}

type HeadGetData404JSONResponse MetaV1ErrorResponse

func (response HeadGetData404JSONResponse) VisitHeadGetDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PatchDataRequestObject struct {
	Name                                 string `json:"name"`
	Params                               PatchDataParams
	ApplicationJSONPatchPlusJSONBody     *PatchDataApplicationJSONPatchPlusJSONRequestBody
	ApplicationVndStyraPatchPlusJSONBody *PatchDataApplicationVndStyraPatchPlusJSONRequestBody
}

type PatchDataResponseObject interface {
	VisitPatchDataResponse(w http.ResponseWriter) error
}

type PatchData200JSONResponse DataV1DataPatchResponse

func (response PatchData200JSONResponse) VisitPatchDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type PatchData404JSONResponse MetaV1ErrorResponse

func (response PatchData404JSONResponse) VisitPatchDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PatchData413JSONResponse MetaV1ErrorResponse

func (response PatchData413JSONResponse) VisitPatchDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response)
}

type ShowDataRequestObject struct {
	Name     string `json:"name"`
	Params   ShowDataParams
	JSONBody *ShowDataJSONRequestBody
	TextBody *ShowDataTextRequestBody
}

type ShowDataResponseObject interface {
	VisitShowDataResponse(w http.ResponseWriter) error
}

type ShowData200ResponseHeaders struct {
	Etag string
}

type ShowData200JSONResponse struct {
	Body    DataV1DataResponse
	Headers ShowData200ResponseHeaders
}

func (response ShowData200JSONResponse) VisitShowDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type ShowData304Response struct {
}

func (response ShowData304Response) VisitShowDataResponse(w http.ResponseWriter) error {
	w.WriteHeader(304)
	return nil
}

type ShowData404JSONResponse MetaV1ErrorResponse

func (response ShowData404JSONResponse) VisitShowDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PutDataRequestObject struct {
	Name                                string `json:"name"`
	Params                              PutDataParams
	JSONBody                            *PutDataJSONRequestBody
	ApplicationVndStyraPushPlusJSONBody *PutDataApplicationVndStyraPushPlusJSONRequestBody
	Body                                io.Reader
}

type PutDataResponseObject interface {
	VisitPutDataResponse(w http.ResponseWriter) error
}

type PutData200ResponseHeaders struct {
	Etag string
}

type PutData200JSONResponse struct {
	Body    DataV1DataPutResponse
	Headers PutData200ResponseHeaders
}

func (response PutData200JSONResponse) VisitPutDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.Header().Set("Etag", fmt.Sprint(response.Headers.Etag))
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response.Body)
}

type PutData404JSONResponse MetaV1ErrorResponse

func (response PutData404JSONResponse) VisitPutDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type PutData413JSONResponse MetaV1ErrorResponse

func (response PutData413JSONResponse) VisitPutDataResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(413)

	return json.NewEncoder(w).Encode(response)
}

type LibrariesListRequestObject struct {
}

type LibrariesListResponseObject interface {
	VisitLibrariesListResponse(w http.ResponseWriter) error
}

type LibrariesList200JSONResponse LibrariesV1LibrariesListResponse

func (response LibrariesList200JSONResponse) VisitLibrariesListResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type SourceControlVerifyConfigLibraryRequestObject struct {
	Body *SourceControlVerifyConfigLibraryJSONRequestBody
}

type SourceControlVerifyConfigLibraryResponseObject interface {
	VisitSourceControlVerifyConfigLibraryResponse(w http.ResponseWriter) error
}

type SourceControlVerifyConfigLibrary200JSONResponse GitV1VerifyConfigResponse

func (response SourceControlVerifyConfigLibrary200JSONResponse) VisitSourceControlVerifyConfigLibraryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type SourceControlVerifyConfigLibrary400JSONResponse MetaV1ErrorResponse

func (response SourceControlVerifyConfigLibrary400JSONResponse) VisitSourceControlVerifyConfigLibraryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(400)

	return json.NewEncoder(w).Encode(response)
}

type LibrariesDeleteRequestObject struct {
	Id string `json:"id"`
}

type LibrariesDeleteResponseObject interface {
	VisitLibrariesDeleteResponse(w http.ResponseWriter) error
}

type LibrariesDelete200Response struct {
}

func (response LibrariesDelete200Response) VisitLibrariesDeleteResponse(w http.ResponseWriter) error {
	w.WriteHeader(200)
	return nil
}

type LibrariesGetRequestObject struct {
	Id string `json:"id"`
}

type LibrariesGetResponseObject interface {
	VisitLibrariesGetResponse(w http.ResponseWriter) error
}

type LibrariesGet200JSONResponse LibrariesV1LibraryResponse

func (response LibrariesGet200JSONResponse) VisitLibrariesGetResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type LibrariesUpdateRequestObject struct {
	Id   string `json:"id"`
	Body *LibrariesUpdateJSONRequestBody
}

type LibrariesUpdateResponseObject interface {
	VisitLibrariesUpdateResponse(w http.ResponseWriter) error
}

type LibrariesUpdate200JSONResponse LibrariesV1LibraryResponse

func (response LibrariesUpdate200JSONResponse) VisitLibrariesUpdateResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserBranchLibraryRequestObject struct {
	Id string `json:"id"`
}

type DeleteUserBranchLibraryResponseObject interface {
	VisitDeleteUserBranchLibraryResponse(w http.ResponseWriter) error
}

type DeleteUserBranchLibrary200JSONResponse GitV1DeleteBranchResponse

func (response DeleteUserBranchLibrary200JSONResponse) VisitDeleteUserBranchLibraryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeleteUserBranchLibrary404JSONResponse MetaV1ErrorResponse

func (response DeleteUserBranchLibrary404JSONResponse) VisitDeleteUserBranchLibraryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetSourceControlFilesBranchLibraryRequestObject struct {
	Id string `json:"id"`
}

type GetSourceControlFilesBranchLibraryResponseObject interface {
	VisitGetSourceControlFilesBranchLibraryResponse(w http.ResponseWriter) error
}

type GetSourceControlFilesBranchLibrary200JSONResponse GitV1GetFilesResponse

func (response GetSourceControlFilesBranchLibrary200JSONResponse) VisitGetSourceControlFilesBranchLibraryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetSourceControlFilesBranchLibrary404JSONResponse MetaV1ErrorResponse

func (response GetSourceControlFilesBranchLibrary404JSONResponse) VisitGetSourceControlFilesBranchLibraryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type CommitFilesToSourceControlLibraryRequestObject struct {
	Id   string `json:"id"`
	Body *CommitFilesToSourceControlLibraryJSONRequestBody
}

type CommitFilesToSourceControlLibraryResponseObject interface {
	VisitCommitFilesToSourceControlLibraryResponse(w http.ResponseWriter) error
}

type CommitFilesToSourceControlLibrary200JSONResponse GitV1PostCommitResponse

func (response CommitFilesToSourceControlLibrary200JSONResponse) VisitCommitFilesToSourceControlLibraryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type CommitFilesToSourceControlLibrary404JSONResponse MetaV1ErrorResponse

func (response CommitFilesToSourceControlLibrary404JSONResponse) VisitCommitFilesToSourceControlLibraryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetSourceControlFilesMasterLibraryRequestObject struct {
	Id string `json:"id"`
}

type GetSourceControlFilesMasterLibraryResponseObject interface {
	VisitGetSourceControlFilesMasterLibraryResponse(w http.ResponseWriter) error
}

type GetSourceControlFilesMasterLibrary200JSONResponse GitV1GetFilesResponse

func (response GetSourceControlFilesMasterLibrary200JSONResponse) VisitGetSourceControlFilesMasterLibraryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetSourceControlFilesMasterLibrary404JSONResponse MetaV1ErrorResponse

func (response GetSourceControlFilesMasterLibrary404JSONResponse) VisitGetSourceControlFilesMasterLibraryResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type ListPoliciesRequestObject struct {
	Params ListPoliciesParams
}

type ListPoliciesResponseObject interface {
	VisitListPoliciesResponse(w http.ResponseWriter) error
}

type ListPolicies200JSONResponse PoliciesV1PoliciesListResponse

func (response ListPolicies200JSONResponse) VisitListPoliciesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type BulkUploadPoliciesRequestObject struct {
	Body io.Reader
}

type BulkUploadPoliciesResponseObject interface {
	VisitBulkUploadPoliciesResponse(w http.ResponseWriter) error
}

type BulkUploadPolicies200JSONResponse PoliciesV1PoliciesBulkUploadResponse

func (response BulkUploadPolicies200JSONResponse) VisitBulkUploadPoliciesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListPlaygroundPoliciesRequestObject struct {
	Params ListPlaygroundPoliciesParams
}

type ListPlaygroundPoliciesResponseObject interface {
	VisitListPlaygroundPoliciesResponse(w http.ResponseWriter) error
}

type ListPlaygroundPolicies200JSONResponse PoliciesV1PoliciesListResponse

func (response ListPlaygroundPolicies200JSONResponse) VisitListPlaygroundPoliciesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type BulkUploadPlaygroundPoliciesRequestObject struct {
	Body io.Reader
}

type BulkUploadPlaygroundPoliciesResponseObject interface {
	VisitBulkUploadPlaygroundPoliciesResponse(w http.ResponseWriter) error
}

type BulkUploadPlaygroundPolicies200JSONResponse PoliciesV1PoliciesBulkUploadResponse

func (response BulkUploadPlaygroundPolicies200JSONResponse) VisitBulkUploadPlaygroundPoliciesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type ListSystemPoliciesRequestObject struct {
	System string `json:"system"`
	Params ListSystemPoliciesParams
}

type ListSystemPoliciesResponseObject interface {
	VisitListSystemPoliciesResponse(w http.ResponseWriter) error
}

type ListSystemPolicies200JSONResponse PoliciesV1PoliciesListResponse

func (response ListSystemPolicies200JSONResponse) VisitListSystemPoliciesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type BulkUploadSystemPoliciesRequestObject struct {
	System string `json:"system"`
	Body   io.Reader
}

type BulkUploadSystemPoliciesResponseObject interface {
	VisitBulkUploadSystemPoliciesResponse(w http.ResponseWriter) error
}

type BulkUploadSystemPolicies200JSONResponse PoliciesV1PoliciesBulkUploadResponse

func (response BulkUploadSystemPolicies200JSONResponse) VisitBulkUploadSystemPoliciesResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeletePolicyRequestObject struct {
	Policy string `json:"policy"`
}

type DeletePolicyResponseObject interface {
	VisitDeletePolicyResponse(w http.ResponseWriter) error
}

type DeletePolicy200JSONResponse PoliciesV1PolicyDeleteResponse

func (response DeletePolicy200JSONResponse) VisitDeletePolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type DeletePolicy404JSONResponse MetaV1ErrorResponse

func (response DeletePolicy404JSONResponse) VisitDeletePolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type GetPolicyRequestObject struct {
	Policy string `json:"policy"`
	Params GetPolicyParams
}

type GetPolicyResponseObject interface {
	VisitGetPolicyResponse(w http.ResponseWriter) error
}

type GetPolicy200JSONResponse PoliciesV1PolicyGetResponse

func (response GetPolicy200JSONResponse) VisitGetPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

type GetPolicy404JSONResponse MetaV1ErrorResponse

func (response GetPolicy404JSONResponse) VisitGetPolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(404)

	return json.NewEncoder(w).Encode(response)
}

type UpdatePolicyRequestObject struct {
	Policy string `json:"policy"`
	Params UpdatePolicyParams
	Body   *UpdatePolicyJSONRequestBody
}

type UpdatePolicyResponseObject interface {
	VisitUpdatePolicyResponse(w http.ResponseWriter) error
}

type UpdatePolicy200JSONResponse PoliciesV1PolicyPutResponse

func (response UpdatePolicy200JSONResponse) VisitUpdatePolicyResponse(w http.ResponseWriter) error {
	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(200)

	return json.NewEncoder(w).Encode(response)
}

// StrictServerInterface represents all server handlers.
type StrictServerInterface interface {
	// List data
	// (GET /v1/data)
	ListData(ctx context.Context, request ListDataRequestObject) (ListDataResponseObject, error)
	// Check size of data
	// (HEAD /v1/data)
	HeadListData(ctx context.Context, request HeadListDataRequestObject) (HeadListDataResponseObject, error)
	// Show all data
	// (POST /v1/data)
	ShowAllData(ctx context.Context, request ShowAllDataRequestObject) (ShowAllDataResponseObject, error)
	// Get data
	// (GET /v1/data/{name})
	GetData(ctx context.Context, request GetDataRequestObject) (GetDataResponseObject, error)
	// Check the size of the data
	// (HEAD /v1/data/{name})
	HeadGetData(ctx context.Context, request HeadGetDataRequestObject) (HeadGetDataResponseObject, error)
	// Patch data
	// (PATCH /v1/data/{name})
	PatchData(ctx context.Context, request PatchDataRequestObject) (PatchDataResponseObject, error)
	// Show data
	// (POST /v1/data/{name})
	ShowData(ctx context.Context, request ShowDataRequestObject) (ShowDataResponseObject, error)
	// Publish data
	// (PUT /v1/data/{name})
	PutData(ctx context.Context, request PutDataRequestObject) (PutDataResponseObject, error)
	// List all libraries
	// (GET /v1/libraries)
	LibrariesList(ctx context.Context, request LibrariesListRequestObject) (LibrariesListResponseObject, error)
	// Verify git access
	// (POST /v1/libraries/source-control/verify-config)
	SourceControlVerifyConfigLibrary(ctx context.Context, request SourceControlVerifyConfigLibraryRequestObject) (SourceControlVerifyConfigLibraryResponseObject, error)
	// Delete a library
	// (DELETE /v1/libraries/{id})
	LibrariesDelete(ctx context.Context, request LibrariesDeleteRequestObject) (LibrariesDeleteResponseObject, error)
	// Get a library
	// (GET /v1/libraries/{id})
	LibrariesGet(ctx context.Context, request LibrariesGetRequestObject) (LibrariesGetResponseObject, error)
	// Upsert a new library
	// (PUT /v1/libraries/{id})
	LibrariesUpdate(ctx context.Context, request LibrariesUpdateRequestObject) (LibrariesUpdateResponseObject, error)
	// Delete a user-owned branch
	// (DELETE /v1/libraries/{id}/branch)
	DeleteUserBranchLibrary(ctx context.Context, request DeleteUserBranchLibraryRequestObject) (DeleteUserBranchLibraryResponseObject, error)
	// List files in Styra DAS-created branch.
	// (GET /v1/libraries/{id}/branch)
	GetSourceControlFilesBranchLibrary(ctx context.Context, request GetSourceControlFilesBranchLibraryRequestObject) (GetSourceControlFilesBranchLibraryResponseObject, error)
	// Commit files to library source control
	// (POST /v1/libraries/{id}/commits)
	CommitFilesToSourceControlLibrary(ctx context.Context, request CommitFilesToSourceControlLibraryRequestObject) (CommitFilesToSourceControlLibraryResponseObject, error)
	// List files in current branch.
	// (GET /v1/libraries/{id}/master)
	GetSourceControlFilesMasterLibrary(ctx context.Context, request GetSourceControlFilesMasterLibraryRequestObject) (GetSourceControlFilesMasterLibraryResponseObject, error)
	// List policies
	// (GET /v1/policies)
	ListPolicies(ctx context.Context, request ListPoliciesRequestObject) (ListPoliciesResponseObject, error)
	// Bulk upload policies
	// (POST /v1/policies)
	BulkUploadPolicies(ctx context.Context, request BulkUploadPoliciesRequestObject) (BulkUploadPoliciesResponseObject, error)
	// List playground policies
	// (GET /v1/policies/playground)
	ListPlaygroundPolicies(ctx context.Context, request ListPlaygroundPoliciesRequestObject) (ListPlaygroundPoliciesResponseObject, error)
	// Bulk upload playground policies
	// (POST /v1/policies/playground)
	BulkUploadPlaygroundPolicies(ctx context.Context, request BulkUploadPlaygroundPoliciesRequestObject) (BulkUploadPlaygroundPoliciesResponseObject, error)
	// List system policies
	// (GET /v1/policies/systems/{system})
	ListSystemPolicies(ctx context.Context, request ListSystemPoliciesRequestObject) (ListSystemPoliciesResponseObject, error)
	// Bulk upload system policies
	// (POST /v1/policies/systems/{system})
	BulkUploadSystemPolicies(ctx context.Context, request BulkUploadSystemPoliciesRequestObject) (BulkUploadSystemPoliciesResponseObject, error)
	// Delete a policy
	// (DELETE /v1/policies/{policy})
	DeletePolicy(ctx context.Context, request DeletePolicyRequestObject) (DeletePolicyResponseObject, error)
	// Get a policy
	// (GET /v1/policies/{policy})
	GetPolicy(ctx context.Context, request GetPolicyRequestObject) (GetPolicyResponseObject, error)
	// Update a policy
	// (PUT /v1/policies/{policy})
	UpdatePolicy(ctx context.Context, request UpdatePolicyRequestObject) (UpdatePolicyResponseObject, error)
}

type StrictHandlerFunc = strictnethttp.StrictHttpHandlerFunc
type StrictMiddlewareFunc = strictnethttp.StrictHttpMiddlewareFunc

type StrictHTTPServerOptions struct {
	RequestErrorHandlerFunc  func(w http.ResponseWriter, r *http.Request, err error)
	ResponseErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

func NewStrictHandler(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: StrictHTTPServerOptions{
		RequestErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		},
		ResponseErrorHandlerFunc: func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusInternalServerError)
		},
	}}
}

func NewStrictHandlerWithOptions(ssi StrictServerInterface, middlewares []StrictMiddlewareFunc, options StrictHTTPServerOptions) ServerInterface {
	return &strictHandler{ssi: ssi, middlewares: middlewares, options: options}
}

type strictHandler struct {
	ssi         StrictServerInterface
	middlewares []StrictMiddlewareFunc
	options     StrictHTTPServerOptions
}

// ListData operation middleware
func (sh *strictHandler) ListData(w http.ResponseWriter, r *http.Request, params ListDataParams) {
	var request ListDataRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListData(ctx, request.(ListDataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListData")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListDataResponseObject); ok {
		if err := validResponse.VisitListDataResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// HeadListData operation middleware
func (sh *strictHandler) HeadListData(w http.ResponseWriter, r *http.Request, params HeadListDataParams) {
	var request HeadListDataRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.HeadListData(ctx, request.(HeadListDataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "HeadListData")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(HeadListDataResponseObject); ok {
		if err := validResponse.VisitHeadListDataResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ShowAllData operation middleware
func (sh *strictHandler) ShowAllData(w http.ResponseWriter, r *http.Request, params ShowAllDataParams) {
	var request ShowAllDataRequestObject

	request.Params = params
	if strings.HasPrefix(r.Header.Get("Content-Type"), "application/json") {

		var body ShowAllDataJSONRequestBody
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
			return
		}
		request.JSONBody = &body
	}

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ShowAllData(ctx, request.(ShowAllDataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ShowAllData")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ShowAllDataResponseObject); ok {
		if err := validResponse.VisitShowAllDataResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetData operation middleware
func (sh *strictHandler) GetData(w http.ResponseWriter, r *http.Request, name string, params GetDataParams) {
	var request GetDataRequestObject

	request.Name = name
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetData(ctx, request.(GetDataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetData")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetDataResponseObject); ok {
		if err := validResponse.VisitGetDataResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// HeadGetData operation middleware
func (sh *strictHandler) HeadGetData(w http.ResponseWriter, r *http.Request, name string, params HeadGetDataParams) {
	var request HeadGetDataRequestObject

	request.Name = name
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.HeadGetData(ctx, request.(HeadGetDataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "HeadGetData")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(HeadGetDataResponseObject); ok {
		if err := validResponse.VisitHeadGetDataResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PatchData operation middleware
func (sh *strictHandler) PatchData(w http.ResponseWriter, r *http.Request, name string, params PatchDataParams) {
	var request PatchDataRequestObject

	request.Name = name
	request.Params = params
	if strings.HasPrefix(r.Header.Get("Content-Type"), "application/json-patch+json") {

		var body PatchDataApplicationJSONPatchPlusJSONRequestBody
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
			return
		}
		request.ApplicationJSONPatchPlusJSONBody = &body
	}
	if strings.HasPrefix(r.Header.Get("Content-Type"), "application/vnd.styra.patch+json") {

		var body PatchDataApplicationVndStyraPatchPlusJSONRequestBody
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
			return
		}
		request.ApplicationVndStyraPatchPlusJSONBody = &body
	}

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PatchData(ctx, request.(PatchDataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PatchData")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PatchDataResponseObject); ok {
		if err := validResponse.VisitPatchDataResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ShowData operation middleware
func (sh *strictHandler) ShowData(w http.ResponseWriter, r *http.Request, name string, params ShowDataParams) {
	var request ShowDataRequestObject

	request.Name = name
	request.Params = params
	if strings.HasPrefix(r.Header.Get("Content-Type"), "application/json") {

		var body ShowDataJSONRequestBody
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
			return
		}
		request.JSONBody = &body
	}

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ShowData(ctx, request.(ShowDataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ShowData")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ShowDataResponseObject); ok {
		if err := validResponse.VisitShowDataResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// PutData operation middleware
func (sh *strictHandler) PutData(w http.ResponseWriter, r *http.Request, name string, params PutDataParams) {
	var request PutDataRequestObject

	request.Name = name
	request.Params = params
	if strings.HasPrefix(r.Header.Get("Content-Type"), "application/json") {

		var body PutDataJSONRequestBody
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
			return
		}
		request.JSONBody = &body
	}
	if strings.HasPrefix(r.Header.Get("Content-Type"), "application/octet-stream") {
		request.Body = r.Body
	}
	if strings.HasPrefix(r.Header.Get("Content-Type"), "application/vnd.styra.push+json") {

		var body PutDataApplicationVndStyraPushPlusJSONRequestBody
		if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
			sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
			return
		}
		request.ApplicationVndStyraPushPlusJSONBody = &body
	}
	if strings.HasPrefix(r.Header.Get("Content-Type"), "application/vnd.styra.push+sjson") {
		request.Body = r.Body
	}

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.PutData(ctx, request.(PutDataRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "PutData")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(PutDataResponseObject); ok {
		if err := validResponse.VisitPutDataResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// LibrariesList operation middleware
func (sh *strictHandler) LibrariesList(w http.ResponseWriter, r *http.Request) {
	var request LibrariesListRequestObject

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.LibrariesList(ctx, request.(LibrariesListRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "LibrariesList")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(LibrariesListResponseObject); ok {
		if err := validResponse.VisitLibrariesListResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// SourceControlVerifyConfigLibrary operation middleware
func (sh *strictHandler) SourceControlVerifyConfigLibrary(w http.ResponseWriter, r *http.Request) {
	var request SourceControlVerifyConfigLibraryRequestObject

	var body SourceControlVerifyConfigLibraryJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.SourceControlVerifyConfigLibrary(ctx, request.(SourceControlVerifyConfigLibraryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "SourceControlVerifyConfigLibrary")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(SourceControlVerifyConfigLibraryResponseObject); ok {
		if err := validResponse.VisitSourceControlVerifyConfigLibraryResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// LibrariesDelete operation middleware
func (sh *strictHandler) LibrariesDelete(w http.ResponseWriter, r *http.Request, id string) {
	var request LibrariesDeleteRequestObject

	request.Id = id

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.LibrariesDelete(ctx, request.(LibrariesDeleteRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "LibrariesDelete")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(LibrariesDeleteResponseObject); ok {
		if err := validResponse.VisitLibrariesDeleteResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// LibrariesGet operation middleware
func (sh *strictHandler) LibrariesGet(w http.ResponseWriter, r *http.Request, id string) {
	var request LibrariesGetRequestObject

	request.Id = id

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.LibrariesGet(ctx, request.(LibrariesGetRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "LibrariesGet")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(LibrariesGetResponseObject); ok {
		if err := validResponse.VisitLibrariesGetResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// LibrariesUpdate operation middleware
func (sh *strictHandler) LibrariesUpdate(w http.ResponseWriter, r *http.Request, id string) {
	var request LibrariesUpdateRequestObject

	request.Id = id

	var body LibrariesUpdateJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.LibrariesUpdate(ctx, request.(LibrariesUpdateRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "LibrariesUpdate")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(LibrariesUpdateResponseObject); ok {
		if err := validResponse.VisitLibrariesUpdateResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeleteUserBranchLibrary operation middleware
func (sh *strictHandler) DeleteUserBranchLibrary(w http.ResponseWriter, r *http.Request, id string) {
	var request DeleteUserBranchLibraryRequestObject

	request.Id = id

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeleteUserBranchLibrary(ctx, request.(DeleteUserBranchLibraryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeleteUserBranchLibrary")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeleteUserBranchLibraryResponseObject); ok {
		if err := validResponse.VisitDeleteUserBranchLibraryResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetSourceControlFilesBranchLibrary operation middleware
func (sh *strictHandler) GetSourceControlFilesBranchLibrary(w http.ResponseWriter, r *http.Request, id string) {
	var request GetSourceControlFilesBranchLibraryRequestObject

	request.Id = id

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetSourceControlFilesBranchLibrary(ctx, request.(GetSourceControlFilesBranchLibraryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSourceControlFilesBranchLibrary")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetSourceControlFilesBranchLibraryResponseObject); ok {
		if err := validResponse.VisitGetSourceControlFilesBranchLibraryResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// CommitFilesToSourceControlLibrary operation middleware
func (sh *strictHandler) CommitFilesToSourceControlLibrary(w http.ResponseWriter, r *http.Request, id string) {
	var request CommitFilesToSourceControlLibraryRequestObject

	request.Id = id

	var body CommitFilesToSourceControlLibraryJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.CommitFilesToSourceControlLibrary(ctx, request.(CommitFilesToSourceControlLibraryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "CommitFilesToSourceControlLibrary")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(CommitFilesToSourceControlLibraryResponseObject); ok {
		if err := validResponse.VisitCommitFilesToSourceControlLibraryResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetSourceControlFilesMasterLibrary operation middleware
func (sh *strictHandler) GetSourceControlFilesMasterLibrary(w http.ResponseWriter, r *http.Request, id string) {
	var request GetSourceControlFilesMasterLibraryRequestObject

	request.Id = id

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetSourceControlFilesMasterLibrary(ctx, request.(GetSourceControlFilesMasterLibraryRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetSourceControlFilesMasterLibrary")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetSourceControlFilesMasterLibraryResponseObject); ok {
		if err := validResponse.VisitGetSourceControlFilesMasterLibraryResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListPolicies operation middleware
func (sh *strictHandler) ListPolicies(w http.ResponseWriter, r *http.Request, params ListPoliciesParams) {
	var request ListPoliciesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListPolicies(ctx, request.(ListPoliciesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListPolicies")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListPoliciesResponseObject); ok {
		if err := validResponse.VisitListPoliciesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// BulkUploadPolicies operation middleware
func (sh *strictHandler) BulkUploadPolicies(w http.ResponseWriter, r *http.Request) {
	var request BulkUploadPoliciesRequestObject

	request.Body = r.Body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.BulkUploadPolicies(ctx, request.(BulkUploadPoliciesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "BulkUploadPolicies")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(BulkUploadPoliciesResponseObject); ok {
		if err := validResponse.VisitBulkUploadPoliciesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListPlaygroundPolicies operation middleware
func (sh *strictHandler) ListPlaygroundPolicies(w http.ResponseWriter, r *http.Request, params ListPlaygroundPoliciesParams) {
	var request ListPlaygroundPoliciesRequestObject

	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListPlaygroundPolicies(ctx, request.(ListPlaygroundPoliciesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListPlaygroundPolicies")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListPlaygroundPoliciesResponseObject); ok {
		if err := validResponse.VisitListPlaygroundPoliciesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// BulkUploadPlaygroundPolicies operation middleware
func (sh *strictHandler) BulkUploadPlaygroundPolicies(w http.ResponseWriter, r *http.Request) {
	var request BulkUploadPlaygroundPoliciesRequestObject

	request.Body = r.Body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.BulkUploadPlaygroundPolicies(ctx, request.(BulkUploadPlaygroundPoliciesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "BulkUploadPlaygroundPolicies")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(BulkUploadPlaygroundPoliciesResponseObject); ok {
		if err := validResponse.VisitBulkUploadPlaygroundPoliciesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// ListSystemPolicies operation middleware
func (sh *strictHandler) ListSystemPolicies(w http.ResponseWriter, r *http.Request, system string, params ListSystemPoliciesParams) {
	var request ListSystemPoliciesRequestObject

	request.System = system
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.ListSystemPolicies(ctx, request.(ListSystemPoliciesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "ListSystemPolicies")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(ListSystemPoliciesResponseObject); ok {
		if err := validResponse.VisitListSystemPoliciesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// BulkUploadSystemPolicies operation middleware
func (sh *strictHandler) BulkUploadSystemPolicies(w http.ResponseWriter, r *http.Request, system string) {
	var request BulkUploadSystemPoliciesRequestObject

	request.System = system

	request.Body = r.Body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.BulkUploadSystemPolicies(ctx, request.(BulkUploadSystemPoliciesRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "BulkUploadSystemPolicies")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(BulkUploadSystemPoliciesResponseObject); ok {
		if err := validResponse.VisitBulkUploadSystemPoliciesResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// DeletePolicy operation middleware
func (sh *strictHandler) DeletePolicy(w http.ResponseWriter, r *http.Request, policy string) {
	var request DeletePolicyRequestObject

	request.Policy = policy

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.DeletePolicy(ctx, request.(DeletePolicyRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "DeletePolicy")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(DeletePolicyResponseObject); ok {
		if err := validResponse.VisitDeletePolicyResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// GetPolicy operation middleware
func (sh *strictHandler) GetPolicy(w http.ResponseWriter, r *http.Request, policy string, params GetPolicyParams) {
	var request GetPolicyRequestObject

	request.Policy = policy
	request.Params = params

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.GetPolicy(ctx, request.(GetPolicyRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "GetPolicy")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(GetPolicyResponseObject); ok {
		if err := validResponse.VisitGetPolicyResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

// UpdatePolicy operation middleware
func (sh *strictHandler) UpdatePolicy(w http.ResponseWriter, r *http.Request, policy string, params UpdatePolicyParams) {
	var request UpdatePolicyRequestObject

	request.Policy = policy
	request.Params = params

	var body UpdatePolicyJSONRequestBody
	if err := json.NewDecoder(r.Body).Decode(&body); err != nil {
		sh.options.RequestErrorHandlerFunc(w, r, fmt.Errorf("can't decode JSON body: %w", err))
		return
	}
	request.Body = &body

	handler := func(ctx context.Context, w http.ResponseWriter, r *http.Request, request interface{}) (interface{}, error) {
		return sh.ssi.UpdatePolicy(ctx, request.(UpdatePolicyRequestObject))
	}
	for _, middleware := range sh.middlewares {
		handler = middleware(handler, "UpdatePolicy")
	}

	response, err := handler(r.Context(), w, r, request)

	if err != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, err)
	} else if validResponse, ok := response.(UpdatePolicyResponseObject); ok {
		if err := validResponse.VisitUpdatePolicyResponse(w); err != nil {
			sh.options.ResponseErrorHandlerFunc(w, r, err)
		}
	} else if response != nil {
		sh.options.ResponseErrorHandlerFunc(w, r, fmt.Errorf("unexpected response type: %T", response))
	}
}

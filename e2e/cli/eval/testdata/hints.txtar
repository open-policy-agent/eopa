# complete rule conflict: one hint, pretty output
! exec eopa eval --format pretty --data conflict.rego data.p.x
cmp stderr exp/conflict/stderr
cmp stdout exp/conflict/stdout

# default output (no hints)
! exec eopa eval --data conflict.rego data.p.x
cmp stdout exp/conflict/json/stdout
! stderr .

# resursive rule: two errors, one hint
! exec eopa eval --format pretty --data recursive.rego data.p
# NOTE(sr): unstable output ordering, can't use file
stderr '2 errors occurred:'
stderr 'recursive\.rego:2: rego_recursion_error: rule data\.p\.a is recursive: data\.p\.a -> data\.p\.b -> data\.p\.a'
stderr 'recursive\.rego:3: rego_recursion_error: rule data\.p\.b is recursive: data\.p\.b -> data\.p\.a -> data\.p\.b'
stderr 'For more information, see: https://docs.styra.com/opa/errors/rego-recursion-error/rule-name-is-recursive'

# object keys conflict
! exec eopa eval --format pretty --data key-conflict.rego data.p
! stdout .
cmp stderr exp/key-conflict/stderr

# unsafe var
! exec eopa eval --format pretty --data unsafe.rego data.p
! stdout .
cmp stderr exp/unsafe/stderr

# var as rule name
! exec eopa eval --format pretty --data var-as-rule.rego data.p
! stdout .
cmp stderr exp/var-as-rule/stderr

# conflicting rules
! exec eopa eval --format pretty --data conflicting-rules.rego data.p
! stdout .
cmp stderr exp/conflicting-rules/stderr

# match error
! exec eopa eval --format pretty --data match.rego data.p
! stdout .
cmp stderr exp/match/stderr

# arity mismatch
! exec eopa eval --format pretty --data arity-mismatch.rego data.p
! stdout .
cmp stderr exp/arity-mismatch/stderr

# user-defined function arity mismatch
! exec eopa eval --format pretty --data func-mismatch.rego data.p
! stdout .
cmp stderr exp/func-mismatch/stderr

# unused var (strict mode)
! exec eopa eval --format pretty --data unused-var.rego --strict data.p
! stdout .
cmp stderr exp/unused-var/stderr

# not too interesting parser errors below
! exec eopa eval --format pretty --data parse-assign.rego data.p
! stdout .
cmp stderr exp/parse-assign/stderr

! exec eopa eval --format pretty --data parse-identifier.rego data.p
! stdout .
cmp stderr exp/parse-identifier/stderr

! exec eopa eval --format pretty --data parse-left-curly.rego data.p
! stdout .
cmp stderr exp/parse-left-curly/stderr

! exec eopa eval --format pretty --data parse-right-curly.rego data.p
! stdout .
cmp stderr exp/parse-right-curly/stderr

! exec eopa eval --format pretty --data parse-kw.rego data.p
! stdout .
cmp stderr exp/parse-kw/stderr

! exec eopa eval --format pretty --data parse-string.rego data.p
! stdout .
cmp stderr exp/parse-string/stderr

! exec eopa eval --format pretty --data parse-multi-default.rego data.p
! stdout .
cmp stderr exp/parse-multi-default/stderr

-- conflict.rego --
package p
x := 1
x := 2
-- exp/conflict/stdout --
-- exp/conflict/stderr --
1 error occurred: eval_conflict_error: complete rules must not produce multiple outputs
For more information, see: https://docs.styra.com/opa/errors/eval-conflict-error/complete-rules-must-not-produce-multiple-outputs
-- exp/conflict/json/stdout --
{
  "errors": [
    {
      "message": "complete rules must not produce multiple outputs",
      "code": "eval_conflict_error"
    }
  ]
}
-- recursive.rego --
package p
a := b
b := a
-- key-conflict.rego --
package p
obj := {k: v |
	k := "foo"
	some v in [1, 2]
}
-- exp/key-conflict/stderr --
1 error occurred: object insert conflict
For more information, see: https://docs.styra.com/opa/errors/eval-conflict-error/object-keys-must-be-unique
-- unsafe.rego --
package p
allow if foo
-- exp/unsafe/stderr --
1 error occurred: unsafe.rego:2: rego_unsafe_var_error: var foo is unsafe
For more information, see: https://docs.styra.com/opa/errors/rego-unsafe-var-error/var-name-is-unsafe
-- var-as-rule.rego --
package p
allow only if {
	true
}
-- exp/var-as-rule/stderr --
1 error occurred: var-as-rule.rego:2: rego_parse_error: var cannot be used for rule name
For more information, see: https://docs.styra.com/opa/errors/rego-parse-error/var-cannot-be-used-for-rule-name
-- conflicting-rules.rego --
package p
import future.keywords
deny contains "reason"
deny := "reason"
-- exp/conflicting-rules/stderr --
1 error occurred: conflicting-rules.rego:3: rego_type_error: conflicting rules data.p.deny found
For more information, see: https://docs.styra.com/opa/errors/rego-type-error/conflicting-rules-name-found
-- match.rego --
package p
import future.keywords
same if 1 == "1"
-- exp/match/stderr --
1 error occurred: match.rego:3: rego_type_error: match error
	left  : number
	right : string
For more information, see: https://docs.styra.com/opa/errors/rego-type-error/match-error
-- arity-mismatch.rego --
package p
import future.keywords
q if "admin" in split("admin,member")
-- exp/arity-mismatch/stderr --
1 error occurred: arity-mismatch.rego:3: rego_type_error: split: arity mismatch
	have: (string, ???)
	want: (x: string, delimiter: string)
For more information, see: https://docs.styra.com/opa/errors/rego-type-error/arity-mismatch
-- func-mismatch.rego --
package p
import future.keywords
default f(_, _) := false
q := f(input)
-- exp/func-mismatch/stderr --
1 error occurred: func-mismatch.rego:4: rego_type_error: function data.p.f has arity 2, got 1 argument
For more information, see: https://docs.styra.com/opa/errors/rego-type-error/function-has-arity-got-argument
-- unused-var.rego --
package p
import future.keywords
q if {
    user := input.user
}
-- exp/unused-var/stderr --
1 error occurred: unused-var.rego:4: rego_compile_error: assigned var user unused
For more information, see: https://docs.styra.com/opa/errors/rego-compile-error/assigned-var-name-unused
-- parse-assign.rego --
package p
q := "
-- exp/parse-assign/stderr --
3 errors occurred:
parse-assign.rego:2: rego_parse_error: non-terminated string
	q := "
	     ^
parse-assign.rego:2: rego_parse_error: illegal token
	q := "
	     ^
parse-assign.rego:2: rego_parse_error: illegal token
	q := "
	     ^
-- parse-identifier.rego --
package p
allow if {
	"admin" in input roles
}
-- exp/parse-identifier/stderr --
1 error occurred: parse-identifier.rego:3: rego_parse_error: unexpected identifier token: expected \n or ; or }
	"admin" in input roles
	                 ^
For more information, see: https://docs.styra.com/opa/errors/rego-parse-error/unexpected-identifier-token
-- parse-left-curly.rego --
package p
allow if {
    input.roles == {}{
}
-- exp/parse-left-curly/stderr --
1 error occurred: parse-left-curly.rego:3: rego_parse_error: unexpected { token: expected \n or ; or }
	    input.roles == {}{
	                     ^
For more information, see: https://docs.styra.com/opa/errors/rego-parse-error/unexpected-left-curly-token
-- parse-right-curly.rego --
package p
allow if {
    input.roles == {}}
}
-- exp/parse-right-curly/stderr --
1 error occurred: parse-right-curly.rego:4: rego_parse_error: unexpected } token
	}
	^
For more information, see: https://docs.styra.com/opa/errors/rego-parse-error/unexpected-right-curly-token
-- parse-kw.rego --
package p
allow if {
	input.admin true
}
-- exp/parse-kw/stderr --
1 error occurred: parse-kw.rego:3: rego_parse_error: unexpected true keyword: expected \n or ; or }
	input.admin true
	            ^
For more information, see: https://docs.styra.com/opa/errors/rego-parse-error/unexpected-name-keyword
-- parse-string.rego --
package p
allow if {
	input.role "admin"
}
-- exp/parse-string/stderr --
1 error occurred: parse-string.rego:3: rego_parse_error: unexpected string token: expected \n or ; or }
	input.role "admin"
	           ^
For more information, see: https://docs.styra.com/opa/errors/rego-parse-error/unexpected-string-token
-- parse-multi-default.rego --
package p
default q := true
default q := true
-- exp/parse-multi-default/stderr --
1 error occurred: parse-multi-default.rego:1: rego_type_error: multiple default rules data.p.q found at parse-multi-default.rego:2, parse-multi-default.rego:3
For more information, see: https://docs.styra.com/opa/errors/rego-type-error/multiple-default-rules-name-found

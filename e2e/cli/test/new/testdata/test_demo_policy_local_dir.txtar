# This test is for `eopa test new`, and has the following concerns:
# - StyraInc/demo policy handled correctly.
# - The `.` dir is handled correctly.
# - Context: single Rego file.

exec eopa test new -d main.rego allow
! stdout .
cmp stderr exp/stderr
cmp main_test.rego exp/main_test.rego

-- main.rego --
package main.main
import future.keywords
import data.libraries.banking_lib

# pull in Rego extended policies for APIs (enforced by APIs but not GUI)
# extension can override the allowed openapi policies and it can add additional allows
#    (allow overrides deny in the extension)

default allow := false

# METADATA
# entry: true
# custom:
#   test-bootstrap-name: allow
allow if {
    allow_openapi
    not data.extended.deny
}
allow if {
    allow_openapi
    data.extended.deny
    data.extended.allow
}

# look up this api entry; should be partially evaluated to make it O(1)
apientry = entry if {
    some openapiPath, openapiMethod
    entry := data.openapi[openapiPath][openapiMethod]
    lower(input.method) == lower(openapiMethod)
    url_match(input.path, openapiPath)
}

# granted to everyone (needs to be really fast)
# test-bootstrap-name: allow_open_with_all_roles
allow_openapi if {
    apientry.userFeatures[_] in data.libraries.banking_lib.roles["all"]

}

# granted because of role
# test-bootstrap-name: allow_open_with_role
allow_openapi if {
    feature := apientry.userFeatures[_]  # usually just the one
    some possible_role in feature_roles[feature]
    possible_role in data.user.roles[input.username]
}

# Just the inversion of the roles to features map
# Is this leveraging the optimization correctly?
feature_roles[feature] = roles if {
    feature :=  data.libraries.banking_lib.roles[_][_]
    roles := {r | some r;  data.libraries.banking_lib.roles[r][_] == feature}
}

# METADATA
# entry: true
user_features_object.features = user_features | { x | some x in  data.libraries.banking_lib.roles["all"] }

# METADATA
# entry: true
user_features contains feature if {
    some role in data.user.roles[input.username]
    some feature in  data.libraries.banking_lib.roles[role]
}

###########################################
# URL matching and extraction
#   An abomination; need a builtin for this
###########################################

url_match(concrete, abstract) = bindinglist if {
    concrete2 := trim(concrete, "/")
    abstract2 := trim(abstract, "/")
    concretearr := split(concrete2, "/")
    abstractarr := split(abstract2, "/")
    arr_match(concretearr, abstractarr)
    bindinglist := bind(concretearr, abstractarr)
    # glob.match(abstract2, ["/"], concrete2)
}

arr_match(concrete, abstract) if {
    count(concrete) == count(abstract)
    every i, entry in concrete {
        entry_match(entry, abstract[i])
    }
}

entry_match(concrete, abstract) if {
    startswith(abstract, "{")
    endswith(abstract, "}")
}
entry_match(concrete, abstract) if {
    concrete == abstract
}
bind(concrete, abstract) = bl if {
    bl := [concrete[i] | some i, entry in abstract
                  startswith(entry, "{")
                  endswith(entry, "}")]
}

# ideally this would output into the decision log somehow as well
explain(role) if {
    print(role)
}
-- exp/main_test.rego --
package main.main_test

import rego.v1

# Testcases generated from: main.rego:15
# Success case: All inputs defined.
test_success_allow if {
	test_input = {"input": {"method": "EXAMPLE", "path": "EXAMPLE", "username": "EXAMPLE"}}
	data.main.main.allow with input as test_input
}
# Failure case: No inputs defined.
test_fail_allow_no_input if {
	test_input = {}
	not data.main.main.allow with input as test_input
}
# Failure case: Inputs defined, but wrong values.
test_fail_allow_bad_input if {
	test_input = {"input": {"method": "EXAMPLE", "path": "EXAMPLE", "username": "EXAMPLE"}}
	not data.main.main.allow with input as test_input
}

-- exp/stderr --
[INFO] Generating testcases for annotation 'allow'. File destination will be: 'main_test.rego'

